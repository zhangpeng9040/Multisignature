
%% bare_jrnl.tex
%% V1.4b
%% 2015/08/26
%% by Michael Shell
%% see http://www.michaelshell.org/
%% for current contact information.
%%
%% This is a skeleton file demonstrating the use of IEEEtran.cls
%% (requires IEEEtran.cls version 1.8b or later) with an IEEE
%% journal paper.
%%
%% Support sites:
%% http://www.michaelshell.org/tex/ieeetran/
%% http://www.ctan.org/pkg/ieeetran
%% and
%% http://www.ieee.org/

%%*************************************************************************
%% Legal Notice:
%% This code is offered as-is without any warranty either expressed or
%% implied; without even the implied warranty of MERCHANTABILITY or
%% FITNESS FOR A PARTICULAR PURPOSE!
%% User assumes all risk.
%% In no event shall the IEEE or any contributor to this code be liable for
%% any damages or losses, including, but not limited to, incidental,
%% consequential, or any other damages, resulting from the use or misuse
%% of any information contained here.
%%
%% All comments are the opinions of their respective authors and are not
%% necessarily endorsed by the IEEE.
%%
%% This work is distributed under the LaTeX Project Public License (LPPL)
%% ( http://www.latex-project.org/ ) version 1.3, and may be freely used,
%% distributed and modified. A copy of the LPPL, version 1.3, is included
%% in the base LaTeX documentation of all distributions of LaTeX released
%% 2003/12/01 or later.
%% Retain all contribution notices and credits.
%% ** Modified files should be clearly indicated as such, including  **
%% ** renaming them and changing author support contact information. **
%%*************************************************************************


% *** Authors should verify (and, if needed, correct) their LaTeX system  ***
% *** with the testflow diagnostic prior to trusting their LaTeX platform ***
% *** with production work. The IEEE's font choices and paper sizes can   ***
% *** trigger bugs that do not appear when using other class files.       ***                          ***
% The testflow support page is at:
% http://www.michaelshell.org/tex/testflow/



\documentclass[journal]{IEEEtran}

%
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage{url}


\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{mathtools}
%\usepackage{hyperref}
%\usepackage{lmodern}
\usepackage{booktabs}
\usepackage{threeparttable}
\usepackage{float}
\usepackage{color,soul}


\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{tabu}
\usepackage{multirow}

%
% If IEEEtran.cls has not been installed into the LaTeX system files,
% manually specify the path to it like:
% \documentclass[journal]{../sty/IEEEtran}

% Some very useful LaTeX packages include:
% (uncomment the ones you want to load)


% *** MISC UTILITY PACKAGES ***
%
%\usepackage{ifpdf}
% Heiko Oberdiek's ifpdf.sty is very useful if you need conditional
% compilation based on whether the output is pdf or dvi.
% usage:
% \ifpdf
%   % pdf code
% \else
%   % dvi code
% \fi
% The latest version of ifpdf.sty can be obtained from:
% http://www.ctan.org/pkg/ifpdf
% Also, note that IEEEtran.cls V1.7 and later provides a builtin
% \ifCLASSINFOpdf conditional that works the same way.
% When switching from latex to pdflatex and vice-versa, the compiler may
% have to be run twice to clear warning/error messages.






% *** CITATION PACKAGES ***
%
%\usepackage{cite}
% cite.sty was written by Donald Arseneau
% V1.6 and later of IEEEtran pre-defines the format of the cite.sty package
% \cite{} output to follow that of the IEEE. Loading the cite package will
% result in citation numbers being automatically sorted and properly
% "compressed/ranged". e.g., [1], [9], [2], [7], [5], [6] without using
% cite.sty will become [1], [2], [5]--[7], [9] using cite.sty. cite.sty's
% \cite will automatically add leading space, if needed. Use cite.sty's
% noadjust option (cite.sty V3.8 and later) if you want to turn this off
% such as if a citation ever needs to be enclosed in parenthesis.
% cite.sty is already installed on most LaTeX systems. Be sure and use
% version 5.0 (2009-03-20) and later if using hyperref.sty.
% The latest version can be obtained at:
% http://www.ctan.org/pkg/cite
% The documentation is contained in the cite.sty file itself.






% *** GRAPHICS RELATED PACKAGES ***
%
\ifCLASSINFOpdf
  % \usepackage[pdftex]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../pdf/}{../jpeg/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.pdf,.jpeg,.png}
\else
  % or other class option (dvipsone, dvipdf, if not using dvips). graphicx
  % will default to the driver specified in the system graphics.cfg if no
  % driver is specified.
  % \usepackage[dvips]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../eps/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.eps}
\fi
% graphicx was written by David Carlisle and Sebastian Rahtz. It is
% required if you want graphics, photos, etc. graphicx.sty is already
% installed on most LaTeX systems. The latest version and documentation
% can be obtained at:
% http://www.ctan.org/pkg/graphicx
% Another good source of documentation is "Using Imported Graphics in
% LaTeX2e" by Keith Reckdahl which can be found at:
% http://www.ctan.org/pkg/epslatex
%
% latex, and pdflatex in dvi mode, support graphics in encapsulated
% postscript (.eps) format. pdflatex in pdf mode supports graphics
% in .pdf, .jpeg, .png and .mps (metapost) formats. Users should ensure
% that all non-photo figures use a vector format (.eps, .pdf, .mps) and
% not a bitmapped formats (.jpeg, .png). The IEEE frowns on bitmapped formats
% which can result in "jaggedy"/blurry rendering of lines and letters as
% well as large increases in file sizes.
%
% You can find documentation about the pdfTeX application at:
% http://www.tug.org/applications/pdftex





% *** MATH PACKAGES ***
%
%\usepackage{amsmath}
% A popular package from the American Mathematical Society that provides
% many useful and powerful commands for dealing with mathematics.
%
% Note that the amsmath package sets \interdisplaylinepenalty to 10000
% thus preventing page breaks from occurring within multiline equations. Use:
%\interdisplaylinepenalty=2500
% after loading amsmath to restore such page breaks as IEEEtran.cls normally
% does. amsmath.sty is already installed on most LaTeX systems. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/pkg/amsmath





% *** SPECIALIZED LIST PACKAGES ***
%
%\usepackage{algorithmic}
% algorithmic.sty was written by Peter Williams and Rogerio Brito.
% This package provides an algorithmic environment fo describing algorithms.
% You can use the algorithmic environment in-text or within a figure
% environment to provide for a floating algorithm. Do NOT use the algorithm
% floating environment provided by algorithm.sty (by the same authors) or
% algorithm2e.sty (by Christophe Fiorio) as the IEEE does not use dedicated
% algorithm float types and packages that provide these will not provide
% correct IEEE style captions. The latest version and documentation of
% algorithmic.sty can be obtained at:
% http://www.ctan.org/pkg/algorithms
% Also of interest may be the (relatively newer and more customizable)
% algorithmicx.sty package by Szasz Janos:
% http://www.ctan.org/pkg/algorithmicx




% *** ALIGNMENT PACKAGES ***
%
%\usepackage{array}
% Frank Mittelbach's and David Carlisle's array.sty patches and improves
% the standard LaTeX2e array and tabular environments to provide better
% appearance and additional user controls. As the default LaTeX2e table
% generation code is lacking to the point of almost being broken with
% respect to the quality of the end results, all users are strongly
% advised to use an enhanced (at the very least that provided by array.sty)
% set of table tools. array.sty is already installed on most systems. The
% latest version and documentation can be obtained at:
% http://www.ctan.org/pkg/array


% IEEEtran contains the IEEEeqnarray family of commands that can be used to
% generate multiline equations as well as matrices, tables, etc., of high
% quality.




% *** SUBFIGURE PACKAGES ***
%\ifCLASSOPTIONcompsoc
%  \usepackage[caption=false,font=normalsize,labelfont=sf,textfont=sf]{subfig}
%\else
%  \usepackage[caption=false,font=footnotesize]{subfig}
%\fi
% subfig.sty, written by Steven Douglas Cochran, is the modern replacement
% for subfigure.sty, the latter of which is no longer maintained and is
% incompatible with some LaTeX packages including fixltx2e. However,
% subfig.sty requires and automatically loads Axel Sommerfeldt's caption.sty
% which will override IEEEtran.cls' handling of captions and this will result
% in non-IEEE style figure/table captions. To prevent this problem, be sure
% and invoke subfig.sty's "caption=false" package option (available since
% subfig.sty version 1.3, 2005/06/28) as this is will preserve IEEEtran.cls
% handling of captions.
% Note that the Computer Society format requires a larger sans serif font
% than the serif footnote size font used in traditional IEEE formatting
% and thus the need to invoke different subfig.sty package options depending
% on whether compsoc mode has been enabled.
%
% The latest version and documentation of subfig.sty can be obtained at:
% http://www.ctan.org/pkg/subfig




% *** FLOAT PACKAGES ***
%
%\usepackage{fixltx2e}
% fixltx2e, the successor to the earlier fix2col.sty, was written by
% Frank Mittelbach and David Carlisle. This package corrects a few problems
% in the LaTeX2e kernel, the most notable of which is that in current
% LaTeX2e releases, the ordering of single and double column floats is not
% guaranteed to be preserved. Thus, an unpatched LaTeX2e can allow a
% single column figure to be placed prior to an earlier double column
% figure.
% Be aware that LaTeX2e kernels dated 2015 and later have fixltx2e.sty's
% corrections already built into the system in which case a warning will
% be issued if an attempt is made to load fixltx2e.sty as it is no longer
% needed.
% The latest version and documentation can be found at:
% http://www.ctan.org/pkg/fixltx2e


%\usepackage{stfloats}
% stfloats.sty was written by Sigitas Tolusis. This package gives LaTeX2e
% the ability to do double column floats at the bottom of the page as well
% as the top. (e.g., "\begin{figure*}[!b]" is not normally possible in
% LaTeX2e). It also provides a command:
%\fnbelowfloat
% to enable the placement of footnotes below bottom floats (the standard
% LaTeX2e kernel puts them above bottom floats). This is an invasive package
% which rewrites many portions of the LaTeX2e float routines. It may not work
% with other packages that modify the LaTeX2e float routines. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/pkg/stfloats
% Do not use the stfloats baselinefloat ability as the IEEE does not allow
% \baselineskip to stretch. Authors submitting work to the IEEE should note
% that the IEEE rarely uses double column equations and that authors should try
% to avoid such use. Do not be tempted to use the cuted.sty or midfloat.sty
% packages (also by Sigitas Tolusis) as the IEEE does not format its papers in
% such ways.
% Do not attempt to use stfloats with fixltx2e as they are incompatible.
% Instead, use Morten Hogholm'a dblfloatfix which combines the features
% of both fixltx2e and stfloats:
%
% \usepackage{dblfloatfix}
% The latest version can be found at:
% http://www.ctan.org/pkg/dblfloatfix




%\ifCLASSOPTIONcaptionsoff
%  \usepackage[nomarkers]{endfloat}
% \let\MYoriglatexcaption\caption
% \renewcommand{\caption}[2][\relax]{\MYoriglatexcaption[#2]{#2}}
%\fi
% endfloat.sty was written by James Darrell McCauley, Jeff Goldberg and
% Axel Sommerfeldt. This package may be useful when used in conjunction with
% IEEEtran.cls'  captionsoff option. Some IEEE journals/societies require that
% submissions have lists of figures/tables at the end of the paper and that
% figures/tables without any captions are placed on a page by themselves at
% the end of the document. If needed, the draftcls IEEEtran class option or
% \CLASSINPUTbaselinestretch interface can be used to increase the line
% spacing as well. Be sure and use the nomarkers option of endfloat to
% prevent endfloat from "marking" where the figures would have been placed
% in the text. The two hack lines of code above are a slight modification of
% that suggested by in the endfloat docs (section 8.4.1) to ensure that
% the full captions always appear in the list of figures/tables - even if
% the user used the short optional argument of \caption[]{}.
% IEEE papers do not typically make use of \caption[]'s optional argument,
% so this should not be an issue. A similar trick can be used to disable
% captions of packages such as subfig.sty that lack options to turn off
% the subcaptions:
% For subfig.sty:
% \let\MYorigsubfloat\subfloat
% \renewcommand{\subfloat}[2][\relax]{\MYorigsubfloat[]{#2}}
% However, the above trick will not work if both optional arguments of
% the \subfloat command are used. Furthermore, there needs to be a
% description of each subfigure *somewhere* and endfloat does not add
% subfigure captions to its list of figures. Thus, the best approach is to
% avoid the use of subfigure captions (many IEEE journals avoid them anyway)
% and instead reference/explain all the subfigures within the main caption.
% The latest version of endfloat.sty and its documentation can obtained at:
% http://www.ctan.org/pkg/endfloat
%
% The IEEEtran \ifCLASSOPTIONcaptionsoff conditional can also be used
% later in the document, say, to conditionally put the References on a
% page by themselves.




% *** PDF, URL AND HYPERLINK PACKAGES ***
%
%\usepackage{url}
% url.sty was written by Donald Arseneau. It provides better support for
% handling and breaking URLs. url.sty is already installed on most LaTeX
% systems. The latest version and documentation can be obtained at:
% http://www.ctan.org/pkg/url
% Basically, \url{my_url_here}.




% *** Do not adjust lengths that control margins, column widths, etc. ***
% *** Do not use packages that alter fonts (such as pslatex).         ***
% There should be no need to do such things with IEEEtran.cls V1.6 and later.
% (Unless specifically asked to do so by the journal or conference you plan
% to submit to, of course. )


% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}


\begin{document}
%
% paper title
% Titles are generally capitalized except for words such as a, an, and, as,
% at, but, by, for, in, nor, of, on, or, the, to and up, which are usually
% not capitalized unless they are the first or last word of the title.
% Linebreaks \\ can be used within to get better formatting as desired.
% Do not put math or special symbols in the title.
\title{Secure and Efficient Multi-Signature Schemes for Fabric: An Enterprise Blockchain Platform}
%
%
% author names and IEEE memberships
% note positions of commas and nonbreaking spaces ( ~ ) LaTeX will not break
% a structure at a ~ so this keeps an author's name from being broken across
% two lines.
% use \thanks{} to gain access to the first footnote area
% a separate \thanks must be used for each paragraph as LaTeX2e's \thanks
% was not built to handle multiple paragraphs
%

\author{Yue Xiao, Peng Zhang, Yuhong Liu% <-this % stops a space
\thanks{Peng Zhang is the corresponding author.}
\thanks{This work was in part supported by the National Natural Science Foundation of China (61702342, 61872243).}
\thanks{Y. Xiao and P. Zhang are with the College
of Electronics and Information Engineering, Shenzhen University, Shenzhen 518060, China (e-mail: xiaoyue2017@email.szu.edu.cn; zhangp@szu.edu.cn ).}% <-this % stops a space
\thanks{Y. Liu is with the Department of Computer Engineering, Santa Clara University, Santa Clara 95053, USA (e-mail: yhliu@scu.edu).}% <-this % stops a space
}

% note the % following the last \IEEEmembership and also \thanks -
% these prevent an unwanted space from occurring between the last author name
% and the end of the author line. i.e., if you had this:
%
% \author{....lastname \thanks{...} \thanks{...} }
%                     ^------------^------------^----Do not want these spaces!
%
% a space would be appended to the last name and could cause every name on that
% line to be shifted left slightly. This is one of those "LaTeX things". For
% instance, "\textbf{A} \textbf{B}" will typeset as "A B" not "AB". To get
% "AB" then you have to do: "\textbf{A}\textbf{B}"
% \thanks is no different in this regard, so shield the last } of each \thanks
% that ends a line with a % and do not let a space in before the next \thanks.
% Spaces after \IEEEmembership other than the last one are OK (and needed) as
% you are supposed to have spaces between the names. For what it is worth,
% this is a minor point as most people would not even notice if the said evil
% space somehow managed to creep in.



% The paper headers
\markboth{Journal of \LaTeX\ Class Files}
%,~Vol.~14, No.~8, August~2015}%
{Shell \MakeLowercase{\textit{et al.}}: Bare Demo of IEEEtran.cls for IEEE Journals}
% The only time the second header will appear is for the odd numbered pages
% after the title page when using the twoside option.
%
% *** Note that you probably will NOT want to include the author's ***
% *** name in the headers of peer review papers.                   ***
% You can use \ifCLASSOPTIONpeerreview for conditional compilation here if
% you desire.




% If you want to put a publisher's ID mark on the page you can do it like
% this:
%\IEEEpubid{0000--0000/00\$00.00~\copyright~2015 IEEE}
% Remember, if you use this you must call \IEEEpubidadjcol in the second
% column for its text to clear the IEEEpubid mark.



% use for special paper notices
%\IEEEspecialpapernotice{(Invited Paper)}




% make the title area
\maketitle

% As a general rule, do not put math, special symbols or citations
% in the abstract or keywords.
\begin{abstract}
Digital signature is a major component of transactions on Blockchain platforms, especially in enterprise Blockchain platforms, where multiple signatures from a set of peers need to be produced to endorse a transaction. However, such process is often complex and time-consuming. Multi-signature, which can improve transaction efficiency by having a set of signers cooperate to produce a joint signature, has attracted extensive attentions. In this work, we propose two multi-signature schemes, GMS and AGMS, which are proved to be more secure and efficient than state-of-the-art multi-signature schemes. Besides, we implement the proposed schemes in a real Enterprise Blockchain platform, Fabric. Experiment results show that the proposed AGMS scheme helps achieve the goal of high transaction efficiency, low storage complexity, as well as high robustness against rogue-key attacks and \(k\)-sum problem attacks.
\end{abstract}

% Note that keywords are not normally used for peerreview papers.
\begin{IEEEkeywords}
Multi-signature, Blockchain, Fabric, Schnorr signature, Gamma signature.
\end{IEEEkeywords}

% For peer review papers, you can put extra information on the cover
% page as needed:
% \ifCLASSOPTIONpeerreview
% \begin{center} \bfseries EDICS Category: 3-BBND \end{center}
% \fi
%
% For peerreview papers, this IEEEtran command inserts a page break and
% creates the second title. It will be ignored for other modes.
\IEEEpeerreviewmaketitle



\section{Introduction}
% The very first letter is a 2 line initial drop letter followed
% by the rest of the first word in caps.
%
% form to use if the first word consists of a single letter:
% \IEEEPARstart{A}{demo} file is ....
%
% form to use if you need the single drop letter followed by
% normal text (unknown if ever used by the IEEE):
% \IEEEPARstart{A}{}demo file is ....
%
% Some journals put the first two words in caps:
% \IEEEPARstart{T}{his demo} file is ....
%
% Here we have the typical use of a "T" for an initial drop letter
% and "HIS" in caps to complete the first word.
\IEEEPARstart{A}{s} an emerging distributed ledger technology, Blockchain \cite{08nakamoto2008bitcoin} has shown great potential to transform business and finance fields. Recently, several banks, such as J.P. Morgan and Banco Santander S.A., have started to launch Blockchain based platforms in capital markets, which are characterized by ``huge sums of money, multiple stakeholders and lots of coordination" \cite{JP_Morgan}. As transactions in capital markets often require approvals from multiple parties, where each party has to identify whether information matches transaction history and follows the rules created by the participants, the approval process is often complex and time consuming. It is believed that Blockchain can effectively help cut costs and smooth transactions among multiple parties \cite{JP_Morgan}.

It is worth mentioning that Fabric \cite{11DBLP:conf/eurosys/AndroulakiBBCCC18}, an open-source permissioned Blockchain platform for enterprise use cases, has enabled endorsement functions to allow a set of endorsers to approve the execution of a transaction. Cryptographic digital signatures have been adopted to guarantee the validity of endorsements from all endorsers before a transaction can be added to the Blockchain ledger.

However, the endorsement process based on cryptographic digital signatures is often resource consuming, inefficient, and lack of scalability. In particular, to avoid inconsistency in transaction states, a signature needs to be collected from each endorser according to the endorsement policy. The verification of these signatures consumes large amounts of computational resources. After verification, these signatures, which can occupy a significant amount of storage space in a transaction, will be stored in a block and broadcast over the entire Blockchain network. Due to the large computation and communication overhead, the overall throughput of Fabric is about 100 to 2000 tps, which is very low and easily leads to network transmission delay.

A promising approach to improve the throughput is multi-signature \cite{18itakura1983public}, which allows a group of users to sign on a single message, and produces a joint signature that stands for all signers' agreement on the message. Generally, a joint signature has the same length as a single signature, and only needs to be verified once with the public keys of signers that participate. Therefore, compared to digital signature, multi-signature has many advantages such as lower bandwidth, less storage space, and faster verification. Multi-signature has been applied in many fields, including distributed certificate authorities \cite{45DBLP:conf/ccs/SzalachowskiMP14}, directory authorities \cite{38DBLP:journals/corr/SytaTVWF15}, and timestamping services \cite{02DBLP:conf/sp/SytaTVWJGGKF16}.

There are three major categories of multi-signature schemes, as RSA-based, BLS-based, and Schnorr-based multi-signature schemes. Compared to the other two types of schemes, the Schnorr-based multi-signature schemes can well balance the trade off between computational complexity and required storage space, and therefore attract extensive research attentions recently. For example, based on Schnorr signature \cite{09DBLP:journals/joc/Schnorr91}, BN multi-signature scheme \cite{04DBLP:conf/ccs/BellareN06} is designed by adding one more round in signing algorithm. BCJ multi-signature scheme \cite{35DBLP:conf/ccs/BagherzandiCJ08} is presented to eliminate the adding round by homomorphic trapdoor commitments. Gregory et al. design Musig multi-signature scheme \cite{DBLP:journals/dcc/MaxwellPSW19} to improve BN scheme. One of the most popular multi-signature schemes is CoSi \cite{02DBLP:conf/sp/SytaTVWJGGKF16}, which introduces a spanning tree structure to make it easily scale to thousands of signers. However, CoSi can be easily forged by rogue-key attacks and \(k\)-sum problem attacks \cite{03drijverssecurity}. Also, the leader with excessive power in CoSi may replace the message \(m\) to produce another challenge \(c^\prime\).

In this work, we aim to fill the research gap by proposing secure and efficient multi-signature schemes, which can decrease the storage of each transaction, improve the transmission rate of block, and shorten the verification and update time of each node. Our major contributions are described as follows.

\begin{itemize}
    \item Based on Gamma signature \cite{01DBLP:journals/tifs/YaoZ13}, we propose a secure multi-signature scheme named GMS (Gamma Multi-Signature) using proof of possession, which is robust against rogue-key attacks and \(k\)-sum problem attacks. It also addresses the problem of excessive power of the leader in CoSi. In addition, the proposed GMS has achieved strong provable security.

    %which introduces an interactive \(\Gamma\)-protocol to obtain better online performance using proof of possession
    \item To further improve the online performance of GMS, we propose the Advanced Gamma Multi-Signature (AGMS), a more efficient multi-signature scheme. In particular, we propose to change the running order of phases in the signing algorithm to reduce calculation steps after message arrivals. In addition, by enabling the key aggregation algorithm to run together with the signing algorithm, the distributed execution of the key aggregation algorithm is allowed, which further reduces the overall execution time.

    \item Based on the proposed AGMS scheme, we improve the transaction process in Fabric, for which we deploy the multi-signature in and aggregate multiple signatures from endorsers to a joint signature, so as to reduce the size of the transaction and improve the efficiency of endorsement and ledger update. The implementation results also show that our designed transaction process can successfully improve the efficiency and throughput of Fabric.
\end{itemize}

The rest of this paper is organized as follows. Related works are summarized in Section II, followed by preliminaries in Section III. In Section IV, we discuss the two proposed multi-signature schemes GMS and AGMS. The corresponding security analysis and performance analysis are presented in Section V and VI respectively. Finally, the application to Fabric is described in Section VII and Section VIII provides the conclusion.


%we present some subtleties of multi-signature: the rogue-key attack against the Schnorr multi-signature and \(k\)-sum problem attack against CoSi. These attacks are very common and useful to forge a multi-signature. Therefore, in order to overcome these weaknesses,

%At the same time, we introduce the popular scheme called CoSi \cite{02DBLP:conf/sp/SytaTVWJGGKF16}, a well-scalable multi-signature with a spanning tree structure. With great scalability, it attracts a large body of follow-up work. Recently, Manu Drijvers el al. \cite{03drijverssecurity} thought CoSi is not secure enough because it can be reduced to \(k\)-sum problem and propose a new secure multi-signature scheme which is not our focus in this paper.

%The corresponding security analysis and performance analysis are given in detail to show that our Advanced Gamma Multi-Signature is more efficient over other multi-signature schemes.
%We analyze the performance and security of our proposed scheme. Several typical multi-signature schemes are listed to make a comprehensive comparison of our scheme. Meanwhile, we also do some experiments to evaluate our scheme.

% An example of a floating figure using the graphicx package.
% Note that \label must occur AFTER (or within) \caption.
% For figures, \caption should occur after the \includegraphics.
% Note that IEEEtran v1.7 and later has special internal code that
% is designed to preserve the operation of \label within \caption
% even when the captionsoff option is in effect. However, because
% of issues like this, it may be the safest practice to put all your
% \label just after \caption rather than within \caption{}.
%
% Reminder: the "draftcls" or "draftclsnofoot", not "draft", class
% option should be used if it is desired that the figures are to be
% displayed while in draft mode.
%
%\begin{figure}[!t]
%\centering
%\includegraphics[width=2.5in]{myfigure}
% where an .eps filename suffix will be assumed under latex,
% and a .pdf suffix will be assumed for pdflatex; or what has been declared
% via \DeclareGraphicsExtensions.
%\caption{Simulation results for the network.}
%\label{fig_sim}
%\end{figure}

% Note that the IEEE typically puts floats only at the top, even when this
% results in a large percentage of a column being occupied by floats.


% An example of a double column floating figure using two subfigures.
% (The subfig.sty package must be loaded for this to work.)
% The subfigure \label commands are set within each subfloat command,
% and the \label for the overall figure must come after \caption.
% \hfil is used as a separator to get equal spacing.
% Watch out that the combined width of all the subfigures on a
% line do not exceed the text width or a line break will occur.
%
%\begin{figure*}[!t]
%\centering
%\subfloat[Case I]{\includegraphics[width=2.5in]{box}%
%\label{fig_first_case}}
%\hfil
%\subfloat[Case II]{\includegraphics[width=2.5in]{box}%
%\label{fig_second_case}}
%\caption{Simulation results for the network.}
%\label{fig_sim}
%\end{figure*}
%
% Note that often IEEE papers with subfigures do not employ subfigure
% captions (using the optional argument to \subfloat[]), but instead will
% reference/describe all of them (a), (b), etc., within the main caption.
% Be aware that for subfig.sty to generate the (a), (b), etc., subfigure
% labels, the optional argument to \subfloat must be present. If a
% subcaption is not desired, just leave its contents blank,
% e.g., \subfloat[].


% An example of a floating table. Note that, for IEEE style tables, the
% \caption command should come BEFORE the table and, given that table
% captions serve much like titles, are usually capitalized except for words
% such as a, an, and, as, at, but, by, for, in, nor, of, on, or, the, to
% and up, which are usually not capitalized unless they are the first or
% last word of the caption. Table text will default to \footnotesize as
% the IEEE normally uses this smaller font for tables.
% The \label must come after \caption as always.
%
%\begin{table}[!t]
%% increase table row spacing, adjust to taste
%\renewcommand{\arraystretch}{1.3}
% if using array.sty, it might be a good idea to tweak the value of
% \extrarowheight as needed to properly center the text within the cells
%\caption{An Example of a Table}
%\label{table_example}
%\centering
%% Some packages, such as MDW tools, offer better commands for making tables
%% than the plain LaTeX2e tabular which is used here.
%\begin{tabular}{|c||c|}
%\hline
%One & Two\\
%\hline
%Three & Four\\
%\hline
%\end{tabular}
%\end{table}


% Note that the IEEE does not put floats in the very first column
% - or typically anywhere on the first page for that matter. Also,
% in-text middle ("here") positioning is typically not used, but it
% is allowed and encouraged for Computer Society conferences (but
% not Computer Society journals). Most IEEE journals/conferences use
% top floats exclusively.
% Note that, LaTeX2e, unlike IEEE journals/conferences, places
% footnotes above bottom floats. This can be corrected via the
% \fnbelowfloat command of the stfloats package.

\vspace{-2mm}
\section{Related work}
According to the difficulty assumptions and basic signature algorithms, multi-signature schemes can be divided into RSA-based, BLS-based, Schnorr-based, etc. The details are described as follows.
\subsection{Multi-signature schemes derived from RSA signatures}
As the implementation of RSA is particularly efficient, there are some multi-signature schemes proposed under RSA assumption.
Harn et al. \cite{1989New} propose a multi-signature scheme based on RSA for the first time, for which the time to generate and verify multiple signatures depends on the number of signers.
Bellare and Neven \cite{DBLP:conf/ctrsa/BellareN07} propose an identity-based multi-signature scheme which relies on the RSA assumption in the random oracle model. The scheme has fast multi-signature generation and verification, but it takes three rounds of interactions.
Based on \cite{DBLP:conf/ctrsa/BellareN07}, Bagherzandi et al. \cite{DBLP:conf/pkc/BagherzandiJ10} propose an improved identity-based multi-signature scheme and aggregation signature scheme under RSA assumptions. The number of interactive rounds of the scheme is reduced from three to two.
Tsai et al. \cite{DBLP:conf/isbast/TsaiLW13} propose an identity-based sequential aggregation signature scheme which can be seen as a generalization of multi-signature, where each signer signs a different message, and signatures are aggregated in sequence.
Hohenberger et al. \cite{DBLP:conf/eurocrypt/HohenbergerW18} construct a synchronized aggregation signature from RSA, which can be used in Blockchain so that the creation of a new block can be seen as a synchronization event.
Yu et al. \cite{44DBLP:journals/ijdsn/YuZWGXD0Y18} propose the use of multi-signature and Blockchain to ensure security and privacy of the transmitted data in the Internet of Things (IoT) scenario.
Compared to the schemes derived from Schnorr signature, length of signatures in these RSA based schemes is significantly longer for a similar level of security.

\subsection{Multi-signature schemes derived from BLS signatures}

BLS signature \cite{DBLP:conf/asiacrypt/BonehLS01} is proposed based on bilinear paring, where the signature length is just 224-bit compared to the 2048-bit signature in RSA. Based on efficient bilinear parings and elegant BLS signatures, various multi-signature schemes \cite{DBLP:conf/pkc/Boldyreva03}\cite{DBLP:conf/eurocrypt/RistenpartY07}\cite{DBLP:conf/ccs/AmbrosinCINSS16}\cite{07DBLP:conf/asiacrypt/BonehDN18} are proposed.
Particularly, Ambrosin et al. \cite{DBLP:conf/ccs/AmbrosinCINSS16} propose a novel optimistic aggregation signature scheme called OAS to design secure collective attestation for Internet of Things.
Boneh et al. \cite{07DBLP:conf/asiacrypt/BonehDN18} also propose a BLS multi-signatures with public-key aggregation in order to reduce the size of Bitcoin Blockchain.
Compared to the schemes derived from Schnorr signature, these bilinear pairing based schemes can further reduce the key and signature sizes. However, as the bilinear pairing operation is one of the most complex operations in modern cryptography \cite{DBLP:journals/tifs/HeZXH15}, they also introduce high computational overhead.


\subsection{Multi-signature schemes derived from Schnorr signatures}
When one uses a 2048-bit modulus, the corresponding signature lengths for RSA, BLS, and Schnorr based schemes are 2048 bits, 224 bits, and 448 bits, respectively. Although the advantage of BLS signature length is obvious, the high computational cost can not be ignored. Considering both computation and storage, Schnorr signature \cite{09DBLP:journals/joc/Schnorr91}, one of the best-known signature algorithms, is a good choice.
Many multi-signature schemes are proposed based on Schnorr signature.
Bellare and Neven \cite{04DBLP:conf/ccs/BellareN06} have designed BN scheme by adding one more round in the signing algorithm, where all signers involved need to exchange their own commitments. It is proved secure in the plain public-key model.
Then, Bagherzandi et al. \cite{35DBLP:conf/ccs/BagherzandiCJ08} propose BCJ scheme to eliminate the adding round by using homomorphic trapdoor commitments.
Gregory et al. \cite{DBLP:journals/dcc/MaxwellPSW19} design Musig scheme to improve BN scheme in two aspects: holding the same key and signature size with Schnorr signature, and allowing key aggregation. Furthermore, Musig scheme is also applied to Bitcoin network to support key aggregation without revealing the individual signer's public key.
%In particular, a group of signers can cooperatively produce a joint signature, which can be verified by the aggregated public key without interactions. Such a compact and privacy preserving multi-signature can be tailored for n-of-n multi signature transactions to improve the performance and user privacy in Bitcoin. But this scheme requires high communication overhead.

One of the most popular Schnorr based multi-signature schemes is CoSi \cite{02DBLP:conf/sp/SytaTVWJGGKF16}, which requires each node to sign the same message \(m\) by communicating and computing bottom-up in a spanning tree structure. The introduction of the spanning tree structure makes it easy for CoSi to scale up to thousands of signers. Because of its great scalability, CoSi has served as a basis for many multi-signature schemes proposed in later research works \cite{31alangot2018reliable}\cite{28DBLP:conf/uss/Kokoris-KogiasJ16}\cite{29DBLP:conf/sp/SytaJKGGKFF17}\cite{30DBLP:conf/trustcom/ZhouWQHL16}. However, Drijvers et al. \cite{03drijverssecurity} point out that CoSi can be easily forged by rogue-key attacks and \(k\)-sum problem attacks. The leader in CoSi can also forge a joint signature on another message \(m^\prime\) without any other information. Therefore, mBCJ, a new multi-signature scheme modified from CoSi, is proposed to defend against these attacks. Nevertheless, the computation of mBCJ is more complicated and time-consuming. As a summary, although the security of CoSi is challenged, it is efficient and scalable. Although proof of possession can be introduced to improve the security, it will potentially increase the overall computational costs.

Therefore, considering both security and efficiency, we turn to consider other digital signature schemes. Gamma signature \cite{01DBLP:journals/tifs/YaoZ13}, proposed by Yao et al. in 2013, is modified from Schnorr signature. Different from Schnorr signature, Gamma signature can be implemented in two corresponding phases: the offline phase, which pre-computes some partial values without any information of the message \(m\) to be signed, and the online phase, which produces the final signature after the message \(m\) arrives. Compared to Schnorr signature, Gamma signature performs better in several aspects: (1) online performance; (2) flexible and easy deployment in interactive protocols; and (3) great unforgeability against concurrent interactive attacks. To our best knowledge, this work is the first multi-signature scheme based on Gamma signature. Experiment results verify that better online performance can be achieved when compared to the above mentioned Schnorr-based multi-signature schemes.

%Boneh et al. \cite{07DBLP:conf/asiacrypt/BonehDN18} present two kinds of multi-signature schemes that based on bilinear pairing and Schnorr signature respectively, and used them to Bitcoin to further reduce the size of block and compress the data. For the multi-signature scheme based on bilinear pairing, no interaction is required. However, there exists a sophisticated group setup and high computation cost.
% needed in second column of first page if using \IEEEpubid
%\IEEEpubidadjcol

\vspace{-2mm}
\section{Preliminaries}
\subsection{Target One-Way Hash Function}

\noindent\emph{\bf Definition 1 (Target One-Way Hash Function \cite{01DBLP:journals/tifs/YaoZ13}):}
A hash function \(H:\{0,1\}^*\rightarrow\varepsilon\subseteq{\{0,1\}}^{l_0}\) is defined as a \((t_f,\varepsilon_f)\) target one-way hash function w.r.t. an \(e\)-condition \(R_e\) and a set \(D\subseteq\{0,1\}^{l_0}\), if for any probabilistic poly-time adversary \(\mathcal{A}\), there exists a relationship that
\begin{displaymath}
\begin{array}{l}
\textup{Adv}^{\textsf{tow}}_{H}(\mathcal{A})=\\\\
\textup{Pr}
\left[
\begin{array}{l}
R_e(d,e,d^\prime,e^\prime)=0
\end{array}
\middle|
\begin{array}{l}
(m,s)\leftarrow A_1(H,d)\\
m^\prime\leftarrow A_2(H,d,m,d^\prime,s)
\end{array}
\right]\\\\
\leq\textsf{negl} (l_0),
\end{array}
\end{displaymath}
where for any \(t\)-time algorithm \(A=\{A_1,A_2\}\), we assume that  \(e=H(m)\), \(e^\prime=H(m^\prime)\), \(d,d^\prime\leftarrow D\), and \(s\) is defined as some state information passed from \(A_1\) to \(A_2\).

%\subsection{Schnorr Signature}
%\(\Sigma\)-protocol \cite{26pub:21438} is a three-round public-coin honest verifier zero-knowledge protocol used to prove the knowledge of private key \(sk\) corresponding to public key \(pk\). In such a protocol, firstly, the prover needs to send a randomly chosen value \(a\) to the verifier. Then, the verifier sends back a random challenge \(e\). Finally, the prover returns a calculated value \(s\) such that \(s= f_s(a,sk,e)\) to verifier, where \(f_s\) is defined as a deterministic poly-time function. The verifier checks the answer \(s\) by producing an expected value from the given value \((e,s,pk)\) and comparing it with the previously received value \(a\). It is used by Fiat-Shamir (FS) paradigm \cite{25DBLP:conf/crypto/FiatS86} to design a non-interactive digital signature by constructing a hash function such that \(e=H(a,m)\), where \(e\) is modeled as a random oracles (RO) and finally returning the value \((a,s)\) as a signature on \(m\).
%
% As an instantiation of Fiat--Shamir transformation applied to \(\Sigma\) -protocol described above, Schnorr signature \cite{09DBLP:journals/joc/Schnorr91} was firstly proposed by C. P. Schnorr in 1991. It is based on discrete logarithm assumption and proved to be secure in the random oracle model. Due to its characteristics of easiness and efficiency, it gradually becomes the main research destination of many fields such as multi-signature. We review a Schnorr signature scheme \cite{09DBLP:journals/joc/Schnorr91} as follows:\\
%
%\noindent\textbf{Parameter Generation.} We use \(Pg(\kappa)\) to set up a group \(\mathbb{G}\) of order \(q\)  with generator \(g_1\), where \(q\) is defined as a prime with  \(\kappa\)-bit, and finally output \(par=(\mathbb{G},g_1,q)\).
%
%\noindent\textbf{Key Generation.} \(Kg(par)\) randomly selects \(sk\in [0,q-1]\), computes \(pk= g_1^{sk}\) and finally outputs value \((pk,sk)\).
%
%\noindent\textbf{Signing.} This algorithm defines one hash function \(H_0\) such that \(H_0:\{0,1\}^*\rightarrow\mathbb{Z}_q\). A signer runs \(Sign(par,sk,m)\), first randomly chooses a value \(v\in[0,q-1]\) and computes \(V=g_1^v\ modq\). When the message \(m\) comes, it needs to compute hash function \(e=H_0(V,m)\) and \(s=v-e*sk\ modq\). Finally, the signer outputs \(\sigma= (V,s)\) as a signature on the message \(m\).
%
%\noindent\textbf{Verification.} The verifier runs \(Verify(par,pk,m,\sigma)\), firstly computes \(e=H_0(V,m)\) and checks whether it satisfies \(V=g_1^s*pk^e\). If not, the signature is invalid and the verifier rejects it. Else, the verifier accepts the signature.
\subsection{Rogue-Key Attack and \(k\)-Sum Problem Attack}

Rogue-key attack is a very typical attack against multi-signature schemes including CoSi and BN, allowing a corrupted signer to set his/her own public key arbitrarily such as \(X_1=g_1^{sk_1}(\prod_{i=2}^{n} X_i)^{-1}\) so that he/she can independently forge a joint signature on the same messages \(m\) for public keys \(\{X_1,...,X_n\}\).

%Differently, Ballare and Neven \cite{04DBLP:conf/ccs/BellareN06} proceeded to add one more around telecommunication in a multi-signature scheme. However, this may leads to large telecommunication load.
To protect systems against rogue-key attacks, some researchers choose to use a sophisticated key generation protocol. For example, proof of possession, proposed by Ristenpart and Yilek \cite{05DBLP:conf/eurocrypt/RistenpartY07}, is a direct way to defend against this attack.
It is established based on the general key registered model, meaning that the signer is required to provide his/her knowledge of the secret key \(sk\) corresponding to the public key \(pk\) through a non-interactive zero knowledge protocol. This proof is able to stop the corrupted signer forging a joint signature. It is suitable to be applied in Public Key Infrastructure (PKI), where each node has its certificate showing the information about its own public key \(pk\).

%\noindent\textbf{\(k\)-sum problem Attack.}
In addition, as stated in \cite{03drijverssecurity}, there exists \(k\)-sum problem attack that belongs to a \(k\)-dimensional generalization of the birthday problem. It can effectively compromise several multi-signature schemes, such as CoSi \cite{02DBLP:conf/sp/SytaTVWJGGKF16}, Musig \cite{DBLP:journals/dcc/MaxwellPSW19}. In particular, the \(k\)-sum problem is defined as follows.

\noindent\emph{\bf Definition 2 (\(k\)-Sum Problem \cite{03drijverssecurity}):} Given a group \((\mathbb{Z}_q,+)\), an arbitrary \(l_0\)-bit prime \(q\), and \(k\) lists  \(L_1,\cdots,L_k\) with an identical size, where elements in each list are sampled uniformly and randomly from \(\mathbb{Z}_q\), the \(k\)-sum problem aims to find out \(k\) values: \(x_1\in L_1, \cdots,x_k \in L_k\) that satisfy the equation \(x_1+\cdots+x_k\equiv0\ mod\ q\).

We consider that an adversary can successfully launch a \(k\)-sum problem attack if he/she can solve the \(k\)-sum problem by using \(k\) lists with length of \(s_L\), within a total running time of \(\tau\) and certain probability that

%\(k\)-sum problem is defined in group \((\mathbb{Z}_q,+)\) for an arbitrary \(l_0\)-bit prime \(q\), given \(k\) lists with an uniform size \((L_1,\cdots,L_k)\), where elements in each list are sampled uniformly and randomly from \(\mathbb{Z}_q\). Given the \(k\) lists, we need to


\begin{displaymath}
\begin{array}{l}
\textup{Adv}^{\textsf{\(k\)-sum}}_{\mathbb{Z}_q}({\mathcal{A}})=\\\\
\textup{Pr}
\left[
\begin{array}{l}
x_1+\cdots+x_k\equiv0\ mod\ q
\end{array}
\middle|
\begin{array}{l}
L_1,\cdots,L_k\in\mathbb{Z}_q\\
|L_1|=\cdots =|L_k|=s_L\\
x_1\in L_1,\cdots ,x_k\in L_k
\end{array}
\right]\\\\
\geq \textsf{negl} (l_0).
\end{array}
\end{displaymath}

%\(k\)-sum problem attack, another attack to CoSi, is originated from \(k\)-sum problem.
According to the above construction of \(k\)-sum problem, the adversary working as a leader in CoSi needs to simulate the signing algorithm \((k-1)\) times to produce different joint signatures on the same message \(m\), so that it can forge a joint signature on a new message \(m^\prime\) satisfying \(k\)-sum problem. Therefore, an effective way to avoid this attack is to improve the construction of the signing algorithm.

However, rogue-key attack and \(k\)-sum problem attack are not handled in CoSi. Therefore, we propose to adopt proof of possession in key generation algorithm and improve signing algorithm, so that secure multi-signature schemes can be developed against rogue-key attacks and \(k\)-sum problem attacks.

%It's true that CoSi \cite{02DBLP:conf/sp/SytaTVWJGGKF16} is reduced to \(k\)-sum problem described above, which can not satisfy the security requirement.
%It can be verified that CoSi \cite{02DBLP:conf/sp/SytaTVWJGGKF16} is reduced to \(k\)-sum problem that mentioned in \cite{03drijverssecurity}. We make a brief description about it.
%Suppose there is an adversary with its own key pair \((pk,sk)\), and the adversary's work is described follows:
%
%The adversary works as a leader in a tree structure, simulates CoSi \cite{02DBLP:conf/sp/SytaTVWJGGKF16} on a random message \(m\) for \(k-1\) times. It broadcasts \(m\) to its immediate children \(j\in C_j\) and waits for their commitments \(\tilde{V}_i\) as well as their corresponding responses such that \(S_i=\tilde{v}_i-c_i*sk^\prime=\tilde{v}_i-H_0(\tilde{V}_i,\tilde{X},m) *sk^\prime\) for \(k-1\) times, where \(sk^\prime\) stands for the sum of signers' private keys except the adversary. Then, the adversary can forge a valid signature \(\delta=(c^\ast,S^\ast)\) on behalf of the whole signers in the tree structure on announcement \(m^\ast\) that never be signed before such that \(c^\ast=\sum_{i=1}^{k-1} c_i\) and \(S^\ast=\sum_{i=1}^{k-1} S_i-c^\ast*sk\).
%Because \(\tilde{V}^\ast=\sum_{i=1}^{k-1}g_1^{\tilde{v_i}}=\sum_{i=1}^{k-1} \tilde{V}_i\) can be computed and known for the adversary, note that \(c^\ast=H_0(\tilde{V}^\ast,\tilde{X},m^\ast)=\sum_{i=1}^{k-1} c_i\) and \(S^\ast=\sum_{i=1}^{k-1} S_i-c^\ast*sk=\sum_{i=1}^{k-1} \tilde{v}_i-c^\ast(sk^\prime+sk)\), we can know that in order to make the forge signature  \(\delta=(c^\ast,S^\ast)\) valid, it is important to find out \(c^\ast\) that should satisfy \(c^\ast=\sum_{i=1}^{k-1} c_i=\sum_{i=1}^{k-1} H_0(\tilde{V}_i,\tilde{X},m)\). The problem can be reduced to \(k\)-sum problem: \(H_0(\tilde{V}^\ast,\tilde{X},m^\ast)-\sum_{i=1}^{k-1} H_0(\tilde{V}_i,\tilde{X},m)=0\). Therefore, as long as we can find out \(m\), \(m^\ast\) and \(\tilde{V}_i\), where \(1\leq i\leq k-1\), we can solve the \(k\)-sum problem and get  \(c^\ast=H_0(\tilde{V}^\ast,\tilde{X},m^\ast)=\sum_{i=1}^{k-1} H_0(\tilde{V}_i,\tilde{X},m)\). Therefore, it is easy to forge a multi-signature on announcement \(m^\ast\).

\subsection{Gamma Signature}
The improvements to resist attacks and guarantee security will inevitably increase the total computational costs. Hence it is very challenging to consider security and efficiency at the same time. Nevertheless, if we are able to move part of the computational overhead from online to offline, an improvement on both security and online efficiency may be achieved even if the total computational costs (i.e. including both online and offline) are higher.

Gamma signature \cite{01DBLP:journals/tifs/YaoZ13} is such an online/offline signature scheme, which has better online performance compared to Schnorr signature. In particular, it is implemented in two corresponding phases: the offline phase, which pre-computes some partial values without any information of the message \(m\) to be signed, and the online phase, which produces the final signature after the arrival of message \(m\). The detailed procedure of Gamma signature is explained as follows.\\
%In such a protocol, firstly, the prover selects \(r\) and \(d\) respectively, computes a unique value \(a= f(r,pk)\), where \(f\) is a deterministic poly-time function. Then, it sends \((a,d)\) to verifier. After that, the verifier sends back a random challenge \(e\). Finally, the prover receives \(e\), computes \(s= f_s(r,sk,d,e)\) where \(f_s\) is also defined as another deterministic poly-time function and sends it to the verifier. The verifier is able to verify its correctness by producing an expected value from the given value \((d,e,s,pk)\) and comparing it with the previous value \(a\). Different from \(\Sigma\)-protocol, this protocol additionally adds a new random value \(d\), a new function \(a= f(r,pk)\) in first round and takes \(d\) as a partial input of \(f_s\). Besides, it requires a new property called knowledge extraction w.r.t. \(e\)-condition, where we only can extract the knowledge of \(sk\) from two different values \((a,d,e,s)\) and \((a,d^\prime,e^\prime,s^\prime)\).

%\noindent\textbf{Parameter Generation.} Similar to the Schnorr signature, \(Pg(\kappa)\) outputs \(par=(\mathbb{G},g_1,q)\).
%
%\noindent\textbf{Key Generation.} Similar to the Schnorr signature, \(Kg(par)\) outputs a public/private key pair \((pk,sk)\).

\noindent\textbf{Parameter generation.} We use \(\textsf{Pg}(\kappa)\) to set up a group \(\mathbb{G}\) of order \(q\)  with generator \(g_1\), where \(q\) is defined as a prime with  \(\kappa\)-bit, and finally output \(par=(\mathbb{G},g_1,q)\).

\noindent\textbf{Key generation.} \(\textsf{Kg}(par)\) randomly selects \(sk\in [0,q-1]\), computes \(pk= g_1^{sk}\) and finally outputs value \((pk,sk)\).

\noindent\textbf{Signing.} This algorithm defines two kinds of hash functions: \(H_0:\{0,1\}^*\rightarrow\mathbb{Z}_q\) that is modelled as random oracles and \(H_1:\{0,1\}^*\rightarrow\mathbb{Z}_q\) that belongs to a target one-way hash function. A signer runs \(\textsf{Sign}(par,sk,m)\) by first randomly selecting a value \(v\in[0,q-1]\) and pre-computing \(V=g_1^v\ mod\ q\), \(c=H_0(V,pk)\), and \(v*c\). When the message \(m\) comes, the signer can further compute \(e=H_1(m)\) and \(s=v*c-e*sk\ mod\ q\), and output \(\sigma= (c,s)\) as a signature on the message \(m\).

\noindent\textbf{Verification.} To run \(\textsf{Vf}(par,pk,m,\sigma)\), the verifier firstly computes \(e=H_1(m)\), \(V=(g_1^s*pk^e)^{c^{-1}}\ mod\ q\), and then checks whether it satisfies \(H_0(V,pk)=c\). If not, the signature is invalid and the verifier rejects it. Else, the verifier accepts the signature.

Due to its high online efficiency, Gamma signature is adopted in this paper as a basis for the proposed multi-signature schemes. To our best knowledge, this is the first work that proposes multi-signature schemes based on Gamma signature.

%In terms of complexity of offline storage, the signer who implements the Gamma-signature can precompute \(q_s\) values of \((v,v*c)\), whose length only is \(2|q|q_s\). But the signer who implements the Schnorr siganature needs to precompute \(q_s\) values of \((v,V)\), whose length is \((|p|+|q|)q_s\). Compared to Gamma-signature, the offline storage of Schnorr signature is relatively larger. In addition, the value \(c\) can be sent to the verifier in advance. Gamma-signature has advantages over lower complexity of offline storage, ease uses of interactive protocol and strong unforgeability under concurrent interactive attack.

%It is better than the Schnorr signature \cite{09DBLP:journals/joc/Schnorr91} in the several areas:

%(1) Online/offline storage performance. The signer who implements Gamma-signature can precompute \(q_s\) values of \((c,v*c)\) with length of \(2|q|q_s\), which is less than \(q_s\) values of \((v,V)\) with length of \((|p|+|q|)q_s\) in Schnorr signature.

%(2) Flexible and easy deployment in interactive protocols. For Gamma signature, the signer can precompute and send value \(c\) to verifier before knowing the message \(m\), making it easy for Gamma signature to deploy in interactive protocols, but hard for Schnorr signature.

%(3) Great unforgeability in concurrent interactive attack. Gamma-signature involves two different hash function, it can be proved to be more complicated and secure than Schnorr signature.

%Everything has two sides. Gamma-signature also exists some minor drawbacks. Although it makes signature have a better offline storage and strong security, it comes at the cost of computation.
%The offline signing computation of Gamma-signature needs one more hashing and one more modular exponentiation than that of Schnorr signature. Otherwise, it also needs one more hashing, one more modular exponentiation and one more modular inversion when compared with Schnorr signature in \(Verify\) algorithm.
%Although the total computational cost of Gamma signature is a little larger than that of Schnorr signature,

%To sum up,

%this scheme is still suitable, especially for signers that have the low computation storage in offline signing phase and limited computation time in online signing phase. It can be designed for low-power devices such as smart cards, wireless sensors and RFID tags.

%\subsection{cosi multi-signature scheme}
%cosi \cite{02dblp:conf/sp/sytatvwjggkf16}, proposed by syta et al., is a multi-signature scheme with a spanning tree structure. it is a schnorr-based multi-signature with a two-round signing protocol.
%%by constructing such a multi-signature that each node signs the same message \(m\) from bottom to up in a spanning tree structure, it can reasonably distribute the communication and computation across a spanning tree structure to make cosi \cite{02dblp:conf/sp/sytatvwjggkf16} easily scale to thousands of signers and can be verified like a single schnorr signature \cite{09dblp:journals/joc/schnorr91}, which is the most prominent feature of cosi scheme. as a two-round signature protocol, cosi scheme defines one hash function \(h_0\) such that \(h_0:\{0,1\}^*\rightarrow\mathbb{z}_q\), and it consists of five algorithms.\\
%in cosi \cite{02dblp:conf/sp/sytatvwjggkf16}, it reasonably distributes the communication and computation across the spanning tree structure. each node signs the same message \(m\) from bottom to up in this structure. combined with the tree struture, cosi can be easily scale to thousands of signers and verified like a single schnorr signature, which is the most prominent feature of cosi. similar to schnorr signature, cosi defines one hash function \(h_0:\{0,1\}^*\rightarrow\mathbb{z}_q\) that modelled as random oracles. it consists of five algorithms.
%
%\noindent\textbf{parameter generation.} similar to schnorr signature, \(pg(\kappa)\) eventually outputs \(par=(\mathbb{g},g_1,q)\).
%
%\noindent\textbf{key generation.} similar to schnorr signature, \(kg(par)\) eventually outputs a public/private key pair \((pk,sk)\).
%
%\noindent\textbf{key aggregation.} on input all the public keys \(\mathcal{pk}\) involved to sign, \(kag(\mathcal{pk})\) outputs the single aggregate public key \(\tilde{x}= \prod_{pk_i\in\mathcal{pk}}{pk_i}\).
%
%\noindent\textbf{signing.} we set \(c_i\) as a set of children of the signer \(s_i\) in a spanning tree structure. different from other multi-signature scheme, a signer \(s_i\) runs signing algorithm \(sign(par,sk_i,m,\tau)\) in a tree \(\tau\) for four phases, which is showed in fig. \ref{fig8}.
%
%\begin{figure}
%\includegraphics[width=\textwidth]{cosi11standard.jpg}
%\caption{the signing algorithm of cosi \cite{02dblp:conf/sp/sytatvwjggkf16} (we suppose that signer \(s_i\) holds the key pair \((pk_i,sk_i)\) and parent \(p_i\) works as a leader \(s_0\). if parent \(p_i\) is not a leader, it just works the same as signer \(s_i\). finally, the leader outputs \((c,s)\) as the multi-signature.)} \label{fig8}
%\end{figure}
%
%\noindent\emph{phase 1: announcement.} when the leader receives a message \(m\), it starts to multicast the announcement \(m\) to its children from top to bottom in the tree structure.
%
%\noindent\emph{phase 2: commitment.} after waiting for the announcement \(m\) to arrive, each node \(s_i\) including the leader in a tree structure firstly chooses a random secret value \(v_i\) and computes \(v_i=g_1^{v_i}\). then, \(s_i\) waits for each immediate child \(s_j\)'s partial commitment \(\tilde{v}_j\). if any, the node \(s_i\) computes \(\tilde{v}_i=v_i\prod_{j\in c_i} \tilde{v}_j\). if the node \(s_i\) is not the leader \((i=0)\), it sends \(\tilde{v}_i\) to its parent unless the node \(s_i\) is the leader.
%
%\noindent\emph{phase 3: challenge.} the leader waits for each immediate child's partial commitment value \(\tilde{v}_j\) and computes the final commitment \(\tilde{v}=\tilde{v_0}=v_0\prod_{j\in c_i} \tilde{v}_j\). so, the collective challenge is \(c= h_0(\tilde{v},\tilde{x},m)\). after that, the leader sends the shared challenge value \(c\) back to its immediate children \(j\in{c}_j\).
%
%\noindent\emph{phase 4: response.} when \(s_i\) receives \(c\), it can compute \(s_i=v_i-c*sk_i\) and then wait for a partial response \(\tilde{s}_j\) from its immediate children \(j\in c_j\) to compute \(\tilde{s}_i=s_i+\sum_{j\in c_j}{\tilde{s}_j}\). it sends the result \(\tilde{s}_i\) to its parent until the node \(s_i\) is a leader \((i=0)\). finally, the leader receives the final response \(s= \tilde{s}_0=s_i+\sum_{j\in c_j}{\tilde{s}_j}\) and outputs the multi-signature \((c,s)\).
%
%\noindent\textbf{verification.} on input a signature \(\sigma= (c,s)\) on an announcement \(m\) as well as the aggregate public key \(\tilde{x}\), \(verify(par,\tilde{x},m,\sigma)\) computes \(\tilde{v}=g_1^s\tilde{x}^{c}\), checks whether the equation satisfies \(c=h_0(\tilde{v},\tilde{x},m)\). if not, \((c,s)\) is an invalid signature. otherwise, it is valid and the verifier accepts it.


%\subsection{Rogue-key Attack and Proof of Possession}
%Based on the Schnorr signature, a naive way to construct a multi-signature scheme is very simple and efficient, but it is also vulnerable to some attacks.
%
%There are a group of \(n\) signers, and their own public/private key pairs are \((pk_i,sk_i)\), \((i=1,\cdots,n)\). According to Schnorr signature, they randomly choose \(v_i\), generate and broadcast their own partial commitments \(V_i=g_1^{v_i}\) to others. Then, each of them gathers others' partial commitments \(V_i\) and computes the joint value \(c=H_0(\tilde{V},m)\) such that \(\tilde{V}=\prod_{i=1}^{n}V_i\). After that, by using \(sk_i\), each signer produces a signature on message \(m\): \((V_i,s_i)\), where \(s_i=v_i-c*sk_i\). Finally, all the individual signatures can be condensed as a single signature \((\tilde{V},S)\) such that \(S=\sum_{i=1}^{n}s_i\). To verify the signature, the verifier firstly aggregates all the public keys such that \(\tilde{X}=\prod_{i=1}^{n}pk_i\), then computes \(c=H_0(\tilde{V},m)\) and checks whether it satisfies \(\tilde{V}=g_1^S\tilde{X}^c\). Although it is very convenient to use it, it's easy to be forged for this Schnorr multi-signature scheme by rogue-key attack. After knowing other signers' public keys, the adversary with \((pk_1,sk_1)\) can forge its own public key \(pk^\prime=pk_1(\prod_{i=2}^n {pk_i} )^{-1}\) so that it can easily forge a multi-signature represents a group of \(n\) signers on message \(m\) as follows: the adversary chooses a random number \(v^{\prime}\), computes \(\tilde{X}=\prod_{i=1}^n {pk_i}=pk_1\), \(\tilde{V}^\prime=g_1^{v^{\prime}}
%\), \(e=H_0(\tilde{V}^\prime,m)\) and \(s^{\prime}=v^{\prime}-e*sk_1\),
%%just like a normal Schnorr signature.
% which is similar to producing a single Schnorr signature. So, the verifier may mistakenly believe the multi-signature \((\tilde{V}^\prime,s^\prime)\) is valid because \(\tilde{X}=\prod_{i=1}^n {pk_i}=pk_1\) and satisfies \(\tilde{V}^{\prime}=g_1^{s^{\prime}} \tilde{X}^e\).
%
%Because this naive multi-signature scheme can be forged without knowing other signers' corresponding private key, in order to avoid such an attack, Thomas Ristenpart and Scott Yilek proposed Proof of Possession \cite{05DBLP:conf/eurocrypt/RistenpartY07}, which can be established under the Knowledge-of-Secret-Key (KOSK) assumption. It means that the adversary is required to provide the knowledge of secret key corresponding to the public key. This proof can efficiently avoid rogue-key attacks, and make multi-signature scheme more secure.
%\subsection{\(k\)-sum Problem and Attack}

\section{Proposed Multi-Signature Schemes}
As mentioned before, CoSi is an efficient and scalable multi-signature scheme, but it is easily forged by rogue-key attacks and \(k\)-sum problem attacks. The leader in CoSi can also forge a joint signature by producing the final challenge \(c^\prime\) on another message \(m^\prime\). It is of great significance to design a new multi-signature scheme with enhanced security, high scalability, and efficiency.%To achieve this goal, we adopt Gamma signature as basis, and present two multi-signature schemes to mitigate the security vulnerabilities in CoSi while achieving high online efficiency.
%so it can't be proved secure. It is of great significance to study and find out some efficient solution to it.

%In addition, we also find out although CoSi \cite{02DBLP:conf/sp/SytaTVWJGGKF16} is a two-round multi-signature scheme with a spanning tree structure, it needs high requirements for real-time telecommunication. Only when the signer receives its children's partial commitments or responses can it send its own partial commitment or response to its parent. The deeper the depth of spanning tree structure is, the longer it waits. Another factor that influences network telecommunication is the number of signers. Once the number of signers is large enough, it is likely to result in network congestion in such a two-round protocol. This design also requires all the signers to have a high computation speed and large computation storage.
\subsection{Gamma Multi-Signature Scheme}
With the motivation of constructing a more secure, efficient, and scalable multi-signature scheme, we propose a new multi-signature scheme. In particular, we introduce proof of possession to ensure security of the proposed scheme against rogue-key attacks. To reduce the extra computational costs introduced by proof of possession, we adopt Gamma signature \cite{01DBLP:journals/tifs/YaoZ13} as the basis to split the overall computation into online and offline parts, so that the computational complexity for the online part is improved when compared to CoSi signature scheme and make it hard to forge by \(k\)-sum problem attacks. Furthermore, inspired by CoSi, we also adopt the spanning tree structure to improve the scalability of the proposed scheme. As a summary, our design goal is to ensure security against the rogue-key attacks and \(k\)-sum problem attacks, while achieving high online efficiency and scalability.

%we try to modify and optimize CoSi \cite{02DBLP:conf/sp/SytaTVWJGGKF16} to make it perform better. As Gamma-signature \cite{01DBLP:journals/tifs/YaoZ13} is a well-done offline/online signature scheme, it divides \(e=H(pk,m)\) into two independent values \(c\), \(e\), where \(c=H_0(pk,V)\) and \(e=H_3(m)\). Such modular design enables Gamma-signature to have better offline/online computation.
%Since the spanning tree structure is helpful to improve the scalability of multi-signature,
%based on Gamma signature \cite{01DBLP:journals/tifs/YaoZ13}, we aim to design a new multi-signature scheme with a spanning tree structure. It is expected to avoid  and also achieve great scalability.

We firstly propose Gamma Multi-Signature (GMS) scheme. Assume our proposed multi-signature scheme GMS consists of six algorithms \(\textsf{GMS}=\{\textsf{Pg},\textsf{Kg},\textsf{KAg},\textsf{Sign},\textsf{KVf},\textsf{Vf}\}\) and adopts four hash functions:  \(H_0,H_1,H_2,H_3:\{0,1\}^*\rightarrow\mathbb{Z}_q\), where \(H_0\), \(H_1\) are modelled as random oracles and \(H_2\), \(H_3\) are target one-way hash functions. It works as follows.\\

\noindent\textbf{Parameter generation.} We use \(\textsf{Pg}(\kappa)\) to set up a group \(\mathbb{G}\) of order \(q\)  with generator \(g_1\), where \(q\) is defined as a prime with  \(\kappa\)-bit, and finally outputs \(par=(\mathbb{G},g_1,q)\).

\noindent\textbf{Key generation.} \(\textsf{Kg}(par)\) randomly picks \(sk\in [0,q-1]\) as a private key and sets \(y = g_1^{sk}\) as the corresponding public key. Then, it constructs proof of possession \(\pi=(a,d)\) of \(sk\), which is to protect against rogue-key attacks, by choosing \(r\stackrel{\$}{\leftarrow} \mathbb{Z}_q\) and computing \(a= H_1(g_1,g_1^r)\), \(b= H_2(y)\), and \(d= r*a-b*sk\ mod\ q\). Finally, it sets \(pk= (y,\pi)\) and outputs \((pk,sk)\). The proof of possession will be checked by the verifier each time when a new key pair involved to sign is found. Proof of possession is used to defend against rogue-key attacks existing in CoSi.

\noindent\textbf{Key Aggregation.} Given \(\mathcal{PK}\) as the set of all public keys, \(\textsf{KAg}(\mathcal{PK})\) parses each public key \({pk_i}\) involved to sign in \(\mathcal{PK}\) as \( pk_i=(y_i,\pi_i)\),
%if the public key has never been validated before, \(KAg(\mathcal{PK})\) firstly checks whether it satisfies the equation \(c=H(g_1,(g_1^{s_i}y_i^e)^{c^{-1}})\). Otherwise,
and outputs the aggregated public key as \(\tilde{X}= \prod_{pk_i\in\mathcal{PK}}{y_i}\).

\noindent\textbf{Signing.} We set \(C_i=\{C_{ij}\}\) as the set of children of one signer \(S_i\) in the spanning tree structure, and \(P_i\) as the parent of signer \(S_i\). Assume \(S_0\) to be the root of the tree, so called the leader. The signer \(S_i\) runs signing algorithm \(\textsf{Sign}(par,sk_i,m,\tau)\) in a tree \(\tau\) for four phases, which is shown in Fig. \ref{figGMS}.

\begin{figure}
\includegraphics[width=0.5\textwidth]{GMS-eps-converted-to.pdf}
\caption{The signing algorithm of our GMS scheme (We suppose that signer \(S_i\) holds the key pair \((pk_i,sk_i)\), where \(pk_i=(y_i,\pi_i)\), and parent \(P_i\) works as a leader \(S_0\). If parent \(P_i\) is not a leader, it just works as signer \(S_i\). Finally, the leader \(S_0\) outputs \((c,S)\) as the joint signature.)}
\label{figGMS}
\end{figure}

\noindent\emph{\underline{Phase 1: Announcement.}} When the leader \(S_0\) receives a message \(m\), it starts to multicast the announcement \(m\) to its children top-down in the tree structure.

\noindent\emph{\underline{Phase 2: Commitment.}} This process is run in a bottom-up way by each node \(S_i\). Specifically, given a node \(S_i\), after receiving the announcement \(m\), \(S_i\) firstly chooses a random secret value \(v_i\) and computes \(V_i=g_1^{v_i}\). Then, \(S_i\) waits for each immediate child \(j\)'s partial commitment \(\tilde{V}_{ij}\). When all the partial commitments are received, \(S_i\) computes \(\tilde{V}_i=V_i\prod_{j\in C_i} \tilde{V}_{ij}\). After that, the result \(\tilde{V}_i\) is send to its parent \(P_i\) unless \(S_i\) is the leader (i.e. \(i=0\)).

\noindent\emph{\underline{Phase 3: Challenge.}} The leader \(S_0\) waits for each immediate child's partial commitment value \(\tilde{V}_{0j}\) and computes the final commitment \(\tilde{V}=\tilde{V}_0=V_0\prod_{j\in C_0} \tilde{V}_{0j}\). So, the collective challenge is \(c=  H_0(g_1,\tilde{V},\tilde{X})\). The value \(c\), as a part of the joint signature, can be sent to the verifier in advance or stored at the leader. After that, the leader sends the shared challenge value \(c\) back to its children.

\noindent\emph{\underline{Phase 4: Response.}} When \(S_i\) receives \(c\), it can compute the response: \(s_i=v_i*c-e*sk_i\), where \(c= H_0(g_1,\tilde{V},\tilde{X})\) and \(e=H_3(m)\), and wait for each partial response \(\tilde{s}_{ij}\) from its immediate children \(j\). When all the partial responses are received, it sets \(\tilde{s}_i= s_i+\sum_{j\in C_i}{\tilde{s}_{ij}}\). After that, the result \(\tilde{s}_i\) is sent to its parent \(P_i\) unless \(S_i\) is the leader (i.e. \(i=0\)). Finally, the leader \(S_0\) computes the final response \(S= \tilde{s}_0=s_0+\sum_{j\in C_0}{\tilde{s}_{0j}}\) and outputs the joint signature \((c,S)\).

Compared to CoSi, we divide the challenge \(c\) into two independent values \(c\) and \(e\), so as to avoid the excessive power of the leader to replace the message \(m\) with \(m^\prime\) and produce another challenge \(c^\prime\). Through this signature algorithm, the leader is hard to forge a joint signature \((c^\prime,S^\prime)\) by \(k\)-sum problem attacks.

\noindent\textbf{Key Verification.} Similar to Gamma signature, given an input as a public key \(pk\) as well as its corresponding proof of possession such that \(pk=(y,\pi)\), \(\pi=(a,d)\), the key verification algorithm \(\textsf{KVf}(par, pk)\) checks whether it satisfies that \(a=H_1(g_1,V)\), where \(V= (g_1^d y^b)^{a^{-1}}\)  and \(b= H_2(y)\). If not, the public key \(pk\) is invalid and must be discarded.

\noindent\textbf{Verification.} Given an input as a joint signature \(\sigma= (c,S)\) on an announcement \(m\) as well as the aggregated public key \(\tilde{X}\), \(\textsf{Vf}(par,\tilde{X},m,\sigma)\) computes \(e=H_3(m)\) and \(\tilde{V}=(g_1^S \tilde{X}^{e})^{c^{-1}}\), and then checks whether the equation satisfies \(c=H_0(g_1,\tilde{V},\tilde{X})\). If not, \((c,S)\) is an invalid signature. Otherwise, it is valid and the verifier accepts it.

\subsection{Advanced Gamma Multi-Signature Scheme}
From the signature construction of the proposed GMS, it can be seen that the generation of a collective challenge \(c\) has nothing to do with the announcement \(m\). Therefore, if the challenge \(c\) can be precomputed offline, we can change the running order of the above four phases in the signing algorithm to achieve better online performance. Meanwhile, we choose to run key aggregation algorithm in Commitment and Challenge phases, so that it can be executed distributedly. Therefore, the signing algorithm can be modified and optimized from GMS. We call this new scheme as Advanced Gamma Multi-Signature (AGMS).

In AGMS, we define Commitment and Challenge phases as pre-signing phases or offline signing, where each signer in a spanning tree structure comes to an agreement (challenge \(c\)) before the announcement \(m\) arrives. And then, Announcement and Response phases are defined as the formal-signing phases or online signing, where the leader receives the announcement \(m\) to be signed and produces the joint signature \(\sigma= (c,S)\). The signing algorithm in AGMS is described as follows.\\

\noindent\textbf{Signing.} We also set \(C_i=\{C_{ij}\}\) as the set of children of one signer \(S_i\) in the spanning tree structure, and \(P_i\) as the parent of signer \(S_i\). Assume \(S_0\) to be the root of the tree, so called the leader. The signer \(S_i\) runs signing algorithm \(\textsf{Sign}(par,(pk_i, sk_i),m,\tau)\) in a tree \(\tau\) for four phases, which is shown in Fig. \ref{AGMS}.

\begin{figure}
\includegraphics[width=0.5\textwidth]{AGMS-eps-converted-to.pdf}
\caption{The signing algorithm of the proposed AGMS scheme (Text in red indicates changes from Fig. 1. We suppose that signer \(S_i\) holds the key pair \((pk_i,sk_i)\), where \(pk_i=(y_i,\pi_i)\), and parent \(P_i\) works as a leader \(S_0\). If parent \(P_i\) is not a leader, it just works as signer \(S_i\). The key aggregation algorithm also runs together with the signing algorithm. Finally, the leader \(S_0\) outputs \((c,S)\) as the joint signature.)}
\label{AGMS}
\end{figure}

\noindent\emph{\underline{Phase 1: Commitment.}} This process is run in a bottom-up way by each node \(S_i\). Specifically, given a node \(S_i\), choose a random secret value \(v_i\) and compute \(V_i=g_1^{v_i}\). Then, \(S_i\) waits for each immediate child \(j\)'s partial commitment \(\tilde{V}_{ij}\) and the partial aggregated public key \(\tilde{X}_{ij}\). When all the partial commitments are received, \(S_i\) computes \(\tilde{V}_i=V_i\prod_{j\in C_i} \tilde{V}_{ij}\) and \(\tilde{X}_i=y_i\prod_{j\in C_i}{\tilde{X}_{ij}}\). After that, the result \(\tilde{V}_i\) and \(\tilde{X}_i\) is sent to its parent \(P_i\) unless \(S_i\) is the leader (i.e. \(i=0\)).

\noindent\emph{\underline{Phase 2: Challenge.}} The leader \(S_0\) waits for each immediate child's partial commitment value \(\tilde{V}_{0j}\), partial aggregated public key \(\tilde{X}_{0j}\), and computes the final commitment \(\tilde{V}=\tilde{V}_0={V}_0\prod_{j\in C_0}\tilde{V}_{0j}\), as well as the aggregated public key \(\tilde{X}= \tilde{X}_0=y_0\prod_{j\in C_0}{\tilde{X}_{0j}}\). So, the collective challenge is \(c= H_0(g_1,\tilde{V},\tilde{X})\). The value \(c\), as a part of the joint signature, can be sent to the verifier in advance or stored at the leader. After that, the leader sends the shared challenge value \(c\) back to its children. All the signers \(S_i\) store \(c\) and precompute their own partial value \(v_i *c\).

\noindent\emph{\underline{Phase 3: Announcement.}} When the leader \(S_0\) receives a message \(m\), it starts to multicast the announcement \(m\) to its children top-down in the tree structure.

\noindent\emph{\underline{Phase 4: Response.}} When \(S_i\) receives announcement \(m\), it only computes \(e*sk_i\) and adds the previous partial value \(v_i *c\) to attain the individual response: \(s_i=v_i*c-e*sk_i\), where \(e=H_3(m)\). Then, it waits for each partial response \(\tilde{s}_{ij}\) from its immediate child \(j\). When all the partial responses are received, it sets \(\tilde{s}_i= s_i+\sum_{j\in C_i}{\tilde{s}_{ij}}\). After that, the result \(\tilde{s}_i\) is sent to its parent \(P_i\) unless \(S_i\) is the leader (i.e. \(i=0\)). Finally, the leader \(S_0\) computes the final response \(S= \tilde{s}_0=s_0+\sum_{j\in C_0}{\tilde{s}_{0j}}\) and outputs the joint signature \((c,S)\).

In summary, we have proposed two multi-signature schemes GMS and AGMS in this section. GMS focuses on the security improvement, where the verification algorithm for public key is deployed to defeat rogue-key attacks, and the signing algorithm is improved to resist $k$-sum problem attacks and avoid the leader modifying the message to produce another challenge. Meanwhile, the signing algorithm is split into online and offline parts. Furthermore, AGMS focuses on the efficiency improvement, where the running order of phases in signing algorithm is adjusted, and the key aggregation algorithm is executed distributedly, so as to obtain better online performance.

%Compared to GMS, our AGMS multi-signature can offline precompute \(c\) before the message \(m\) comes. This supports \(c\) public or private at the side of the verifier, enabling more efficient online signing and online verification. It also can be proved secure in interactive protocols.

%\noindent\textbf{offline computation and storage complexity.}  in our scheme, the challenge \(c\) can be precomputed before the announcement \(m\) comes. all the signers can implement the pre-signing phase can previously attain and store some challenge values \(c\) for many times, which is as large as hash value. so our scheme has great offline computation and small storage complexity.

%\noindent\textbf{challenge \(c\) can be public or private.} as we can change the sequential running order of original signing algorithm described above, it's possible to let the announcement phase runs together with the challenge phase, which means the leader sends the challenge value \(c\) as well as the announcement \(m\) to its children in a spanning tree structure to further reduce the telecommunication load and therefore shorten the signing time. in addition, the challenge \(c\) can be stored either publicly in a leader or privately at the side of verifier. that is to say, at the end of challenge phase, the leader can choose to send the challenge \(c\) directly to verifier, allowing the verifier to compute some intermediate values in advance, thus saving more time in real-time telecommunication and avoiding too much telecommunication load continuously.

%\noindent\textbf{ease of deployment for interactive protocols.} similar to gamma-signature \cite{01dblp:journals/tifs/yaoz13}, in our proposed gamma multi-signature scheme, we can also compute and send to the verifier a challenge \(c=h_0(g_1,\tilde{v},\tilde{x})\) without knowing the announcement \(m\). therefore, our proposed scheme also can be easily used to implement the interactive protocol such as the (simplified) ikev2 protocol \cite{19dblp:conf/crypto/krawczyk03}. we consider that there exist two different groups of signers, two leaders on behalf of two groups of signers implement the interactive protocol so that our proposed scheme aided implementation of this protocol can enjoy great balanced communication flows and computational loads as gamma signature \cite{01dblp:journals/tifs/yaoz13} does. for cosi, it is difficult to apply cosi scheme to interactive protocol.

\section{Security Analysis}
In this section, we analyze security of the proposed AGMS scheme in details. In particular, security of a multi-signature scheme should satisfy two basic requirements.

First, a multi-signature scheme should be complete. That is, if we build up a system by \(\textsf{Pg}(\kappa)\), generate a set of public and private key pairs \((pk,sk)\) by \(\textsf{Kg}(par)\), and produce a joint signature \(\sigma\) on an announcement \(m\) representing a set of signers in a tree \(\tau\) by \(\textsf{Sign}(par,\mathcal{SK},m,\tau)\), then we should be able to use \(\tilde{X}\), generated from \(\textsf{KAg}(\mathcal{PK})\), to successfully output \(\textsf{KVf}(par,pk)=1\) and \(\textsf{Vf}(par,\tilde{X},m,\sigma)=1\). As these two verification equations are true, the proposed scheme AGMS satisfy the completeness requirement.

Second, a multi-signature scheme should be unforgeable. We prove that the proposed scheme AGMS can achieve unforgeability under current interactive attacks. The analysis is described as follows.

\noindent\emph{Lemma 1 (General forking lemma \cite{04DBLP:conf/ccs/BellareN06}):} Let \(\mathcal{C}\) be a randomized probabilistic algorithm. When given input \((x,h_1,\cdots,h_{q},\rho)\) with access to oracle \(\mathcal{O}\) of size \(\lambda\), where \(x\) is generated by the input generator \(\textsf{IG}\); \(\rho\) refers to \(\mathcal{C}\)'s random tape; \(h_1,\cdots,h_{q}\) are some random chosen values from \(\mathbb{Z}_q\); then \(\mathcal{C}\) outputs a pair \((J,y)\). Let \(\pi\) be the space of all the vectors \((x,h_1,\cdots,h_{q},\rho)\). Let \(acc\) be the probability that \(\mathcal{C}\) can successfully output \((J,y)\) when given inputs \((x,h_1,\cdots,h_{q},\rho)\), where \(J\) is a non-empty subsets of \(\{1,\cdots,q\}\).

For a given \(x\), the forking lemma algorithm \( \ F_{\mathcal{C}} (x)\) is described as follows.

\noindent{\(\ F_{\mathcal{C}} (x)\)}:

Pick a random tape \(\rho\) for \(\mathcal{C}\)

\(h_1,\cdots,h_{q}\leftarrow \mathcal{O}\)

\((J,y)\leftarrow\mathcal{C}(x,h_1,\cdots,h_{q},\rho)\)

if \(J=0\) then

\qquad return \((0,\perp,\perp)\)

\(h_1^\prime,\cdots,h_q^\prime\leftarrow \mathcal{O}\)

\((J^\prime,y^\prime)\leftarrow\mathcal{C}(x,h_1^\prime,\cdots,h_q^\prime,\rho)\)

if \(J=J^\prime\) and \(h_J\neq h^\prime_{J^{\prime}}\)

\qquad return \((1,y,y^\prime)\)

else

\qquad return \((0,\perp,\perp)\)

We let \(frk\) be the probability that \(F_\mathcal{C}\) successfully outputs \((1,y,y^\prime)\) as shown below:
\begin{equation}
frk=\textup{Pr}[b=1:x\leftarrow \textsf{IG};(b,y,y^\prime)\leftarrow F_
\mathcal{C}
(x)] \ .
\end{equation}

 So that we have:
\begin{equation}
frk\geq acc(\frac{acc}{q} - \frac{1}{\lambda}) \ .
\end{equation}

\noindent\emph{Lemma 2:} Let \(\prod =(\textsf{Pg},\textsf{Kg},\textsf{KAg},\textsf{Sign},\textsf{KVf},\textsf{Vf})\) be a multi-signature scheme. We define the security of a multi-signature scheme as the universal unforgeability under a chosen message attack against a set of honest players. We can say CoSi is \((t,q_s,q_f,N,\varepsilon)\)-secure in the random-oracle model, if given \(N\) as the maximum number of participating signers that the adversary needs to run at most \(t\) time, with the probability of forgeability of at least \(\varepsilon\), making at most \(q_s\) signature queries as well as \(q_f\) random oracle queries.

As CoSi is based on Schnorr signature, we follow the random oracle model. In CoSi, we only assume \(H_0(\tilde{V},m)\) are modeled as random oracles, which is only \(t_f,\varepsilon_{cr}\)-collision resistant, so that we may prove CoSi secure in the random oracle under the discrete algorithm assumption. Differently, as for AGMS, we follow the so-called general key registered model \cite{24DBLP:conf/scn/BagherzandiJ08}, where the validity of each public key must be checked by the signature verifier.
In the proposed scheme AGMS, we only assume
\(H_0(g_1,\tilde{V},\tilde{X}):{\{0,1\}}^{\ast}\rightarrow {\{0,1\}}^{\kappa}\) and \(H_1(g_1,u^\ast):{\{0,1\}}^{\ast}\rightarrow {\{0,1\}}^{\kappa}\) are modeled as random oracles, and define the other two hash functions \(H_2(y^\ast):{\{0,1\}}^{\ast}\rightarrow {\{0,1\} }^{\kappa}\) and \(H_3(m):{\{0,1\}}^{\ast}\rightarrow {\{0,1\}}^{\kappa}\) as target one-way hash functions, which are \((t_f,\varepsilon_{cr})\)-collision resistant and \((t_f,\varepsilon_{tow})\)-target one-way, to mitigate the dependency of provable security on random oracles.

\noindent\emph{Theorem 1:} Suppose that AGMS is \((t^\prime,q_s,q_f,N,\varepsilon^\prime)\)-secure under the discrete logarithm problem, there exists an algorithm \(\mathcal{C}\) that if we take uniformly random group elements \(X^\ast\), two uniformly random chosen \(\kappa\)-bit strings \(H_0\), \(H_1\) for a total of \((q_s+q_f)\) times and two target one-way \(\kappa\)-bit strings \(H_2\), \(H_3\) as inputs, then, \(\mathcal{C}\) can successfully output a tuple \((i_0,i_3,\mathcal{PK},S,i_1,i_2)\), satisfying \(\tilde{X}=\prod_{pk_i\in \mathcal{PK}} pk_i\) and  \(H_0(g_1,(g_1^{S}\tilde{X}^{i_3})^{i_0^{-1}},\tilde{X})=i_0\). Here, \(i_0\in (H_{01},\cdots, H_{0 q})\), \(i_1\in (H_{11},\cdots,H_{1 q})\), and \(i_2\), \(i_3\) are the two target one-way hash values involved in the corresponding set of signers' public keys \(\mathcal{PK}\). Assume that \(N\) is the maximum number of signers that participate in AGMS. Then, the running time of algorithm \(\mathcal{C}\) is at most \(t^\prime\), and algorithm \(\mathcal{C}\) succeeds with the probability of \(\varepsilon^\prime\) such that
\begin{equation}
\varepsilon^\prime\geq acc(\frac{acc}{q_s+q_f}-\frac{1}{2^{\kappa}})-\varepsilon_{tow} \ ,\end{equation}
where
\begin{equation}
acc\geq(1-\frac{q_s(2q_f+q_s-1)}{2^{3\kappa+1}})(\varepsilon-\frac{N+1}{2^{\kappa}}-\frac{N(N-1)+2}{2}\varepsilon_{cr}) \ .
\end{equation}

\noindent\emph{Proof:} We construct a four-stage game for an algorithm $\mathcal{C}$ around a $(t,q_s,q_f,N,\varepsilon)$-forger $\mathcal{F}$. Assume that the involved signers behave honestly. Given the random public key set \(\mathcal{PK}=(pk_1,\cdots,pk_N)\), we simulate the game in the following steps.

\noindent\textbf{Setup:} Algorithm \(\mathcal{C}\) initializes \(par=(\mathbb{G},g_1,q)\leftarrow \textsf{Pg}(\kappa)\), \((pk,sk)\leftarrow \textsf{Kg}(par)\), and two empty hash query sets \(S_{H_0}\) and \(S_{H_1}\), corresponding to the queries of \(H_0\) and \(H_1\) respectively such that \((d_{T1},\cdots, d_{Tq_s},d_{T(q_s+1)},\cdots,d_{T(q_s+q_f)})\leftarrow (\{0,1\}^{\kappa})^{q_s+q_f}\), \((T=0,1)\). Then, we construct a ``proof of possession" of \(sk_i\). \(\mathcal{C}\) provides a random tape \(\rho\) to \(\mathcal{F}\), and runs $\mathcal{F}$ as a signer with the public key $pk_1=(y_1,\pi_1)$.

\noindent\textbf{RO queries:} As for CoSi, there only involves one hash value that consists of the final commitment \(\tilde{V}\) and a message \(m\). Differently, in the proposed AGMS, there are two independent hash values to query. For each query set, under the \(i\)-th query \((1\leq i\leq q_f)\) denoted by \(Q_{Ti},(T=0,1)\) from \(\mathcal{F}\), \(\mathcal{C}\) firstly checks whether the value \(Q_{Ti}\) has been defined before. If yes, \(\mathcal{C}\) gives up the repeated value \(H_T(Q_{Ti})=\alpha\). Otherwise, \(\mathcal{C}\) defines \(H_T(Q_{Ti})=d_{T(q_s+i)}\), stores the record \((j=q_s+i,Q_{Ti},H_T(Q_{Ti})=d_{T(q_s+i)})\) in the corresponding set \(S_{H_T}(T=0,1)\) and then sends the values \(d_{T(q_s+i)}\) to \(\mathcal{F}\).

\noindent\textbf{Signature queries:} With the set of public keys \(\mathcal{PK}=(pk_1,\cdots,pk_N)\) and some messages \(m\), \(\mathcal{C}\) firstly simulates each self-signed information \(\pi^\ast=(d^\ast,w^\ast)\) by randomly selecting two values \(d^\ast,w^\ast\stackrel{\$}\leftarrow\mathbb{Z}_q\), and then computing \(u^\ast= (g_1^{w^\ast}y^{\ast b^\ast})^{d^{\ast -1}}\), where \(b^\ast= H_2(y^\ast)\). On input \(pk^\ast=(y^\ast,\pi^\ast)\) with the random tape \(\rho\), \(\mathcal{C}\) makes the query \( H_1(g_1,u^\ast)=d^\ast\). When there exists \(H_1(g_1,u_i^\ast)\) that is never defined in previous queries, \(\mathcal{C}\) sets \(H_1(Q_{1i})=d_{1i}\) and stores \((j=i,Q_{1i},H_1(Q_{1i})=d_{1i})\) in the set \(S_{H_1}\). After receiving \(\tilde{X}=\prod_{pk_i\in \mathcal{PK}} pk_i\) and \(\tilde{V}=\prod_{i=1}^N V_i\) from \(\mathcal{C}\), \(\mathcal{F}\) simulates a query \(c= H_0(g_1,\tilde{V},\tilde{X})\) that is never defined before, stores \((j=i,Q_{0i},H_0(Q_{0i})=d_{0i})\) in the set \(S_{H_0}\) and sends \(c\) to its children without knowing the message \(m\).
\(\mathcal{C}\) can return partial queries value \(c=H_0(Q_{0i})=d_{0i}\) firstly. This is hard for some schemes including CoSi to produce the partial signature value in advance.
Finally, after knowing the message \(m\), similar to signer \(S_i\), \(\mathcal{C}\) waits for the response \(\tilde{s}_{ij}\) that comes from its children \(j\in C_i\), proceeds to compute and send \(\tilde{s_i}= s_i+\sum_{j\in {C}_i} \tilde{s}_{ij}\ mod\ q\) to its parent, where \(s_i=v_i *c-e*sk_i\ mod\ q\). Finally, \(\mathcal{C}\) returns \((c,S)\) as the joint signature.

We assume that there are several cases that may happen and cause \(\mathcal{C}\) to abort the execution. (1) The value \(Q_{0j}\leftarrow(g_1,\tilde{V}_j,\tilde{X}_j)\) that \(\mathcal{F}\) can successfully guess is equal to \(Q_{0i}\leftarrow(g_1,\tilde{V}_i,\tilde{X}_i)\) that is already defined before. (2) \(\mathcal{F}\) successfully attains the value \(Q_{0j}\leftarrow(g_1,\tilde{V}_j,\tilde{X}_j)\) that is never defined before by the birthday paradox. If either of the two cases happens, we set \(bad\leftarrow true\).

\noindent\textbf{Output:} Eventually, $\mathcal{F}$ outputs a forged multi-signature $(c^\prime,S^\prime)$ on the message $m^\prime$ for a multiset $\mathcal{PK}^\prime$. Without loss of generality, we assume the following conditions. (1) All hash queries that are involved in the verification of the forgery; and the proof of possession in \(\mathcal{PK}^\prime\) are made and recorded in sets \(S_T(T=0,1)\). (2) There do not exist any two different values \(Q_{2i}\) and \(Q_{2j}\) in \(\mathcal{PK}^\prime\) such that \(H_2(Q_{2i})=H_2(Q_{2j})=\alpha\). (3) There do not exist any two different values \(Q_{3i}\) and \(Q_{3j}\) such that \(H_3(Q_{3i})=H_3(Q_{3j})=\alpha\). When \(\mathcal{F}\)'s forgery is verified to be true, algorithm \(\mathcal{C}\) halts and returns %\((J,(c^\prime,e^\prime,H_{TJ},S^\prime,\mathcal{PK}^\prime)\).
\((J,(c^\prime,e^\prime,S^\prime,\mathcal{PK}^\prime))\).
If not, algorithm \(\mathcal{C}\) returns \((0,\perp)\) and fails to forge a joint signature.

As we defined above, \(H_T\stackrel{\$}\leftarrow {\{0,1\}}^{\kappa}\) \((T=2,3)\) is a \((t_f,\varepsilon_{tow})\)-target one-way as well as \((t_f,\varepsilon_{cr})\)-collision resistant hash function. Let \(t_s\) denote the running time of a signing query and \(t_{ex}\) denote the running time of extracting \(\mathcal{SK}\) using the generalized forking lemma \(F_\mathcal{C}\). Based on the above description, we can derive that: the event \(bad\leftarrow true\) happens with the probability of
\(\textup{Pr}(bad\leftarrow true)\leq\frac{q_sq_f}{2^{3\kappa}}+\frac{q_s(q_s-1)}{2^{3\kappa+1}}\).
Considering that the event \(bad\leftarrow true\) does not happen, the probability that \(\mathcal{C}\) successfully outputs a forged signature \((c^\prime\,S^\prime)\) satisfying the above requirements is \(acc\geq(1-\frac{q_s(2q_f+q_s-1)}{2^{3\kappa+1}})(\varepsilon-\frac{N+1}{2^{\kappa}}-\frac{N(N-1)+2}{2}\varepsilon_{cr})\). Then, as \(\mathcal{F}\) is described above, algorithm \(\mathcal{C}\) is \((t^\prime,\varepsilon^\prime)\)-break the hash property of one-wayness, where the running time is at most %\(t^\prime=2t+4q_ft_f+(2+2N)q_st_s+O(Nq_s+N)\) and
\(t^\prime=(2N+2)t_f+(2N+2)q_st_s+t_{ex}+O((N+1)q_f)\), and equation (3) and equation (4) are true.

We further prove the theorem in more details by constructing an algorithm \(\mathcal{C}^\prime\). Suppose there is an algorithm $\mathcal{C}^\prime$, given input group elements $X^\ast$ and a signature forger $\mathcal{F}$ that is the same as described above, $\mathcal{C}^\prime$ can solve the discrete logarithm problem in $\mathbb{G}$. Finally, \(\mathcal{C}^\prime\) successfully outputs a forgery, using \(F_\mathcal{C}\) defined in \noindent\emph{Lemma 1}. \(\mathcal{C}^\prime\) proceeds as follows.

%We let \((1,(c,e,h_J,S,N)\) and \((1,(c^\prime,e^\prime,h_J,S^\prime,N^\prime)\) be the two different outputs of \(\mathcal{C}^\prime\) related to the forgery such that:
We set \((1,(c,e,S,N)\) and \((1,(c^\prime,e^\prime,S^\prime,N^\prime)\) as two different outputs of \(\mathcal{C}^\prime\) associated with the forgery such that:
\begin{center}
\(g_1^S=\tilde{V}^c\tilde{X}^{-e}=\tilde{V}^c\prod_{i=1}^N y_i^{-e}\) and \(g_1^{S^\prime}=\tilde{V}^{\prime c^\prime}\tilde{X}^{\prime -e^\prime}=\tilde{V}^{\prime c^\prime}\prod_{i=1}^{N^\prime} y_i^{\prime -e^\prime}\) ,
\end{center}
where we set \(\mathcal{PK}={(pk_1,\cdots,pk_N)}\) and \(\mathcal{PK}^\prime={(pk_1^\prime,\cdots,pk_{N^\prime}^\prime)}\) as two sets of public keys involved in \(\mathcal{F}\)'s forgery. According to the construction of \(\mathcal{C}^\prime\), we should hold \(\tilde{V}^\prime=\tilde{V}\), \(c^{\prime -1}e^{\prime}\neq c^{-1}e\), \(N^\prime=N\) and \(y_i^\prime=y_i(1\leq i \leq N)\). Therefore, we have that:
\begin{equation}
\tilde{V}=g_1^{Sc^{-1}}\prod_{i=1}^{N} y_i^{c^{-1}e},
\end{equation}
and
\begin{equation}
\tilde{V}=g_1^{S^\prime c^{\prime-1}}\prod_{i=1}^{N} y_i^{c^{\prime-1} e^\prime}.
\end{equation}
Based on equations (5) and (6), it will yield:
\begin{equation}
g_1^{Sc^{-1}-S^\prime c^{\prime -1}}=\prod_{i=1}^N y_i^{c^{\prime -1}e^\prime -c^{-1}e}=\prod_{pk_i\in \mathcal{PK}}(y_i)^{c^{\prime -1}e^\prime -c^{-1}e }.
%\(\prod_{i=1}^{N} pk_i^{{e^\prime c^{\prime-1}-ec^{-1}}} = {g_1^{Sc^{-1}-S^\prime c^{\prime-1}}}\)
\end{equation}
Because
 \begin{equation}
 \tilde{X}=\prod_{y_i\in \mathcal{PK}} pk_i=g_1^{\sum_{pk_i\in \mathcal{PK}}sk_i},
 \end{equation}
\(\mathcal{C}^\prime\) can successfully attain the discrete logarithm of \(pk_1\) as
\begin{center}
\(\frac{Sc^{-1}-S^\prime c^{\prime -1}}{c^{\prime -1}e^\prime  -c^{-1}e}-\sum_{pk_i\in \mathcal{PK} \setminus pk_1}sk_i\ mod\ q\) .
\end{center}
That is, if $c^\prime=c$ and $e^\prime\neq e$,the forger $\mathcal{F}$ can successfully extract all $\mathcal{SK}$ except its own $sk_1$. Using \noindent\emph{Lemma 1}, we can compute that the probability for forger \(\mathcal{F}\) to obtain two different outputs, where \(c^\prime\neq c\) or \(e^\prime\neq e\), is \(frk \geq acc(\frac{acc}{q_f+q_s}-\frac{1}{2^{\kappa}})\). Thus,
the probability of \(\mathcal{C}^\prime\) in doing so is given as \( frk \geq acc(\frac{acc}{q_f+q_s}-\frac{1}{2^{\kappa}})-\varepsilon_{tow}\), where \(acc\) satisfies equation (4). The total running time of algorithm \(\mathcal{C}^\prime\) is at most that of \(F_\mathcal{C}\) plus \(O(N)\) operations.
In other words, the proposed scheme AGMS can achieve unforgeability under current interactive attacks.

\section{Performance Analysis}
\subsection{Theoretical Analysis}
In theory, we briefly compare the proposed schemes GMS and AGMS with current most popular multi-signature schemes, including BN \cite{04DBLP:conf/ccs/BellareN06}, CoSi \cite{02DBLP:conf/sp/SytaTVWJGGKF16}, and Musig \cite{DBLP:journals/dcc/MaxwellPSW19}.
%In terms of computation cost, our scheme GMS\&AGMS is only slightly worse than CoSi, but better than any other multi-signature schemes except \(KVerify\) algorithm, which adds proof of possession. For the same reason, the total \(pk\) domain in our GMS\&AGMS is also larger than other multi-signature schemes. We make a detailed description as follows.

The property comparisons of these schemes are summarized in Table \ref{fig11}.
First, based on the prototype of Schnorr signature, these schemes are proved to be standard existential unforgeable under the adaptive chosen message attacks. However, BN, CoSi, and Musig involve only one hash value that consists of the random value and message, meaning that these schemes do not support to precompute the partial signature \(c\) and are possible to be forged by \(k\)-sum problem attacks. Therefore, it is uncertain whether they can be proved secure in concurrent interactive protocols.
Differently, the proposed GMS and AGMS are based on Gamma signature, which involve two different independent hash values, and thus can be secure against \(k\)-sum problem attacks. As the proposed GMS produces the challenge \(c\) after the message \(m\) comes, only the proposed AGMS can achieve provable security in concurrent interactive protocols. That is to say, the leader in AGMS can work as a representative of a group of signers in a spanning tree structure, precompute the challenge \(c\), and achieve two-round interactive telecommunications with other individuals or groups in a secure way. AGMS is also the only scheme that can support the partial signature value \(c\) to be public.
Second, as mentioned before, CoSi is easily to be forged by rogue-key attacks. BN and Musig added one more round protocol to exchange their individual commitments to other signers, which is a solution to avoid rogue-key attacks. But this approach inevitably leads to high communication and computation overhead. The two proposed schemes, GMS and AGMS, use proof of possession, which is an efficient way to avoid rogue-key attacks.
Third, with the spanning tree structure, GMS, AGMS, and CoSi can reach high scalability, which is hard-to-reach by BN or Musig.
%Compared with CoSi \cite{02DBLP:conf/sp/SytaTVWJGGKF16}, we show that our scheme has advantages over CoSi \cite{02DBLP:conf/sp/SytaTVWJGGKF16} for two main aspects: (1) Our scheme adds the proof of possession \cite{05DBLP:conf/eurocrypt/RistenpartY07}, which can effectively avoid the rogue-key attack. But CoSi \cite{02DBLP:conf/sp/SytaTVWJGGKF16} doesn't have this proof or any other effective way to protect against it. So, the leader in a tree structure can successfully forge a valid signature stands for a group of nodes. (2) Our scheme can avoid \(k\)-sum problem. As for CoSi \cite{02DBLP:conf/sp/SytaTVWJGGKF16}, once we find out \(m\), \(m^{\ast}\) and \(\tilde{V}_i\), where \(1\leq i\leq {k-1}\), satisfying \(c^{\ast}=H_0(\prod_{i=1}^{k-1}\tilde{V}_i,\tilde{X},m^{\ast})=\sum_{i=1}^{k-1} H_0({\tilde{V}_i,\tilde{X},m})\ modq\), we can easily forge a multi-signature. That is to say, the main goal is to find out the relationship of \(c^{\ast}\). But our scheme involves two kind of hash function \(c^{\ast}\) and \(e^\ast=H_3(m^\ast)\), which is more complicated than CoSi, so it is difficult to reduce to \(k\)-sum problem and forge by \((k-1)\) times queries. (3) For CoSi scheme \cite{02DBLP:conf/sp/SytaTVWJGGKF16}, it is implemented over (the group of order of \(q\)) \(\mathbb{Z}_p^{\ast}\), where \(p\), \(q\) are typically set as a 1024-bit prime and a 160-bit prime respectively. Before the announcement \(m\) arrives, the signer can precompute \(V\) for \(q_s\) times, thus the offline space complexity is \((|p|+|q|)q_s\), which is the same as that of Schnorr signature \cite{09DBLP:journals/joc/Schnorr91}. For our proposed Gamma Multi-Signature described above, although each signer \(S_i\) also needs to compute \(V_i\), the challenge \(c\) can be precomputed without knowing the announcement \(m\). All the signers in a tree structure can implement the pre-signing phase to attain the challenge \(c\) for \(q_s\)  times, and only store \(q_s\) values of \((c,v_i*c)\) before the announcement \(m\) arrives. Therefore, the offline signature complexity of the signer in our scheme is only \(2|q|q_s\), smaller than that of CoSi \cite{02DBLP:conf/sp/SytaTVWJGGKF16}.
\begin{table*}[htb]
\caption{Properties of several multi-signature schemes}
%\includegraphics[width=\textwidth]{cpcompare.jpg}
\centering
%\setlength{\tabcolsep}{6pt}
%\renewcommand\arraystretch{1}
\begin{tabularx}{\linewidth}{p{5cm}XXXXX}
\toprule Multi-signature schemes&Proposed GMS&Proposed AGMS&BN&CoSi&Musig\\
\midrule
Provable security (Standard)&Yes&Yes&Yes&Yes&Yes\\
Provable security (Concurrent interactive)&Uncertain&Yes&Uncertain&Uncertain&Uncertain\\
Support challenge \(c\) public&No&Yes&No&No&No\\
Against rogue-key attacks&Yes&Yes&Yes&No&Yes\\
Against \(k\)-sum problem attacks&Yes&Yes&No&No&No\\
Rounds&2&2&3&2&3\\
Spanning tree structure&Yes&Yes&No&Yes&No\\
\bottomrule
\end{tabularx}
\label{fig11}
\end{table*}

\begin{table*}[htb]
\caption{Efficiencies of several multi-signature schemes}
%\includegraphics[width=\textwidth]{cpcompare.jpg}
\centering
%setlength{\tabcolsep}{6pt}
%\renewcommand\arraystretch{1}
\begin{tabularx}{\linewidth}{p{5cm}XXXXX}
\toprule Multi-signature schemes&Proposed GMS&Proposed AGMS&BN&CoSi&Musig\\
\midrule
\(\textsf{KAg}\)&- &- &- &- &1\(\cdot\)exp$^N$\\
\(\textsf{Sign}\) (online signing)&1\(\cdot\)exp&- &1\(\cdot\)exp&1\(\cdot\)exp&1\(\cdot\)exp\\
\(\textsf{Sign}\) (offline signing)&-&1\(\cdot\)exp&- &- &- \\
\(\textsf{Vf}\)&1\(\cdot\)exp$^3$&1\(\cdot\)exp$^3$&1\(\cdot\)exp$^{N+1}$&1\(\cdot\)exp$^2$&1\(\cdot\)exp$^2$\\
\(\textsf{KVf}\)&1\(\cdot\)exp$^3$&1\(\cdot\)exp$^3$&- &- &- \\
Total \((\textsf{Sign}+\textsf{Vf})\)&1\(\cdot\)exp$^{N+3}$&1\(\cdot\)exp$^{N+3}$&1\(\cdot\)exp$^{2N+1}$&1\(\cdot\)exp$^{N+2}$&1\(\cdot\)exp$^{N+2}$\\
Signature domain&\(\mathbb{Z}_q^2\)&\(\mathbb{Z}_q^2\)&\(\mathbb{G}\times \mathbb{Z}_q\)&\(\mathbb{Z}_q^2\)&\(\mathbb{G}\times \mathbb{Z}_q\)\\
\(pk\) domain&\(\mathbb{G}\times \mathbb{Z}_q^2\)&\(\mathbb{G}\times \mathbb{Z}_q^2\)&\(\mathbb{G}\)&\(\mathbb{G}\)&\(\mathbb{G}\)\\
\(\tilde{X}\) domain&\(\mathbb{G}\)&\(\mathbb{G}\)&\(\mathbb{G}^N\)&\(\mathbb{G}\)&\(\mathbb{G}\)\\
Offline storage&\(\mathbb{G}\times \mathbb{Z}_q\)&\(\mathbb{G}^2\)&\(\mathbb{G}\times \mathbb{Z}_q\)&\(\mathbb{G}\times \mathbb{Z}_q\)&\(\mathbb{G}\times \mathbb{Z}_q\)\\
\bottomrule
\end{tabularx}
\begin{tablenotes}
\small
%\newline
\item (``-" denotes no exponentiation. ``exp" denotes an exponentiation. ``exp$^k$" denotes an $k$-multi-exponentiation in a group ``\(\mathbb{G}\)". ``\(N\)" denotes the number of signers involved in a multi-signature scheme.)
\end{tablenotes}
\label{fig22}
\end{table*}

Furthermore, we compare the efficiencies of these multi-signature schemes in Table \ref{fig22}.
In particular, Musig needs a very time-consuming \(\textsf{KAg}\) algorithm to construct a more secure joint signature without revealing individual signer's public key.
In the \(\textsf{Sign}\) algorithm, due to the advantage that the challenge \(c\) can be precomputed offline, the proposed AGMS performs better in online signing than all other schemes.
In the \(\textsf{Vf}\) algorithm, the proposed schemes GMS and AGMS require one more exponentiation when compared to BN and Musig.
Because of proof of possession, the two proposed schemes GMS and AGMS also require \(\textsf{KVf}\) algorithm against rogue-key attacks.
The total computation of the \(\textsf{Sign}\) and \(\textsf{Vf}\) algorithms in these two schemes is only slightly higher than that of CoSi and Musig, but much less than that of BN.
In the signature domain and \(\tilde{X}\) domain, the two proposed schemes require the smallest space among these multi-signature schemes. Only the \(pk\) domain needs more space than other schemes due to the proof of possession. In the offline storage, we can suggest that the signer in other schemes except AGMS to precompute and store \((v_i,V_i)\). But the signer in AGMS can store \((v_i,c)\), meaning that in terms of offline storage, AGMS only needs \(\mathbb{G}^2\), which is much smaller than \(\mathbb{G}\times \mathbb{Z}_q\) required by other schemes.
In summary, the proposed GMS and AGMS schemes are comparable to others in terms of efficiency, but AGMS enjoys the greatest efficiency in online signing and the smallest space in offline storage, which can avoid the network congestion and is suitable to be applied in real-time communications.
%Compared with other multi-signature schemes, we also find out our scheme performs greater than those in some areas: (1) In order to avoid the rogue-key attack, BN \cite{04DBLP:conf/ccs/BellareN06} and Musig \cite{DBLP:journals/dcc/MaxwellPSW19} use a 3-round interactive telecommunication to implement a multi-signature, which will exponentially increase the communication load in the network once the number of signers in a group is large enough. Our scheme uses proof of possession [5], this can be verified once before signing. (2) As for BN \cite{04DBLP:conf/ccs/BellareN06} and Musig \cite{DBLP:journals/dcc/MaxwellPSW19}, such design will significantly limits the scalability of multi-signature as well. Our scheme is combined with a spanning tree structure, which distributes the computation and communication load into each node, it greatly avoids the problem mentioned above and has a better scalability.


\subsection{Experimental Analysis}
%As our GMS and AGMS belong to multi-signature schemes with a spanning tree structure, which are similar to CoSi, we aim to evaluate the performance in efficiency and scalability, showing that the design of our schemes can achieve better online signing performance and nearly the same scalability as CoSi.
In this subsection, 32 physical machines that consist of an Intel (R) Core (TM) i7-4790 processor and a RAM with total memory of 8GB are adopted for testing purpose. We implement the following schemes through Go\footnote[1]{http://golang.org/, January, 2015.} programming language. We use hash function SHA-512 \cite{U2012Secure} and SHA-512 based target one-way hash function \cite{01DBLP:journals/tifs/YaoZ13}. We run each experiment for 20 times and show the average results. As the experiment results have significant differences, to show every value, $y$-axis in Fig. [3]-[8] and Fig. [10]-[13] has logarithmic scale.

According to the difficulty assumptions and basic signature algorithms, we test RSA based multi-signature \cite{DBLP:conf/eurocrypt/HohenbergerW18}, BLS based multi-signature \cite{07DBLP:conf/asiacrypt/BonehDN18}, and Schnorr based multi-signature, including CoSi \cite{02DBLP:conf/sp/SytaTVWJGGKF16} and AGMS.
As Gamma signature, the basis of AGMS, is modified from Schnorr signature, and still based on the discrete logarithm problem, AGMS is classified to Schnorr based multi-signature schemes.
These experiments import two Go programming libraries: crypto\footnote[2]{Go cryptography libraries.} and pbc\footnote[3]{https://github.com/Nik-U/pbc, accessed December, 2018.}.
For the same security level, we define the elliptic curve is NIST P-224, and modulus for RSA is 2048-bit.
Through experiments, we have validated that the signature lengths for RSA, BLS, and Schnorr based schemes are 2048 bits, 224 bits, and 448 bits, respectively, indicating that BLS based signatures will take up the smallest storage space. However, as shown in Fig. 3, BLS based signature scheme takes significantly longer running time than the other two categories for both the signing and verification processes, as the bilinear pairing operation is time-consuming. On the other hand, although the time cost for verification algorithm of RSA based multi-signature is low, the total time is very close to that of Schnorr-based schemes (e.g. CoSi, AGMS). In addition, its signature length (2048 bits) will significantly increase the system storage overhead, and is usually unacceptable. With a reasonable signature length (448 bits), the experiment results validate that CoSi and AGMS yield the shortest running time for the signing process and a reasonable running time for the verification process.
Hence, the Schnorr based multi-signature schemes CoSi and AGMS are beneficial for achieving the balance of computational complexity and required storage space.

Next, the two proposed schemes and CoSi are evaluated with a total amount of signers ranging from 128 to 16384, and all the signing nodes are created and connected in a tree structure. As the random depth of tree may influence the results, we set the tree depth to 3 and choose the branching factor according to the number of signers so as to keep it manageable. These experiments import two Go programming libraries: cothority\footnote[4]{https://github.com/dedis/cothority, accessed February, 2018.} and onet\footnote[5]{https://github.com/dedis/onet, accessed February, 2018.}. These schemes are based on elliptic curve 25519, and we ignore the computation time of key aggregation algorithm. From Fig. \ref{fig3}, we can find that, the offset among the total running time of signing and verification algorithms for these schemes is very close when the number of signers is up to 16384. The results confirm that the proposed schemes can easily scale up to thousands of signers as well.

\begin{figure*}[htbp]
\begin{minipage}[t]{0.45\linewidth}
\centering
\includegraphics[width=\textwidth]{FigA2.jpg}
\caption{The running time of signing and verification algorithms of typical difficulty assumptions based multi-signature schemes ($y$-axis has logarithmic scale.)}
\label{figassumption}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.45\linewidth}
\centering
\includegraphics[width=\textwidth]{Fig3.jpg}
\caption{The total CPU running time of signing and verification algorithms for CoSi, GMS, and AGMS. (The three algorithms achieve similar CPU running time, showing that the additional security features of the proposed algorithms do not sacrifice algorithm efficiency. $y$-axis has logarithmic scale.)} \label{fig3}
\end{minipage}%
\end{figure*}

Then, we test the running time of online signing phase and offline signing phase in the proposed AGMS. In the proposed AGMS, the online signing phase consists of the Announcement and Response phases, and the offline signing phase consists of the Commitment and Challenge phases. All the configurations remain the same as those in the first experiment. From the first experiment, we see that the total running time of signing algorithm of AGMS is very close to that of CoSi. As the offline signing phase needs a large amount of elliptic curve exponentiations, it accounts for the vast majority of the total running time of signing algorithm in AGMS. Therefore, the online signing part of the proposed AGMS scheme is very fast. When the number of signers goes up to 16384, we can find that the online signing time of AGMS is less than 1 second, accounting for only about 1\% of total running time of signing algorithm. Fig. \ref{fig4} depicts the results.

Finally, as the leader has heavier computation load in signing algorithm than any other signers, we further test the computation time on a leader node of CoSi and the proposed AGMS in signing algorithm. In this experiment, we also divide signing algorithm into two phases: the former consists of the Announcement and Response phases, and the latter consists of Commitment and Challenge phases. The corresponding results are shown in Fig. \ref{fig5}. We clearly see that it takes much more time for the latter phases than the former phases, since the elliptic curve multiplication is much more complicated than scalar multiplication. Because the Commitment and Challenge phases can be precomputed in the proposed AGMS scheme, while CoSi needs to run all the phases in a sequential way, the proposed AGMS scheme runs absolutely faster than CoSi when we only focus on the computation time on a leader node in online signing phase. The total running time for the online signing phase of the two schemes are compared in Fig. \ref{fig6}.

\begin{figure*}[htbp]
\begin{minipage}[t]{0.45\linewidth}
\centering
\includegraphics[width=\textwidth]{Fig4.jpg}
\caption{The total CPU running time in different phases of signing algorithm in AGMS ($y$-axis has logarithmic scale.)} \label{fig4}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\linewidth}
\centering
\includegraphics[width=\textwidth]{Fig5.jpg}
\caption{The CPU running time on a leader node of CoSi and AGMS in different phases of signing algorithm ($y$-axis has logarithmic scale.)} \label{fig5}
\end{minipage}
\end{figure*}

Memory consumption is another factor to evaluate performance. On the group of 32 physical machines with the above configurations, we test the memory consumption in signing and verification algorithms of CoSi and AGMS with a total amount of signers ranging from 128 to 16384. From Fig. \ref{figmemory}, we can see that on one physical machine the memory consumption of CoSi and AGMS is very similar. Furthermore, as the vast majority of memory consumption is in offline signing phase, we have rather low memory consumption in online signing phase, which is very friendly to low-power devices.

\begin{figure*}
\begin{minipage}[t]{0.45\linewidth}
\centering
\includegraphics[width=\textwidth]{Fig6.jpg}
\caption{The CPU running time on a leader node of CoSi and AGMS in online signing phase ($y$-axis has logarithmic scale.)} \label{fig6}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\linewidth}
\centering
\includegraphics[width=\textwidth]{FigA1.jpg}
\caption{Memory consumption of CoSi and AGMS ($y$-axis has logarithmic scale.)}
\label{figmemory}
\end{minipage}
\end{figure*}

\section{Application to Fabric}
%Since the blockchain-based Bitcoin \cite{08nakamoto2008bitcoin} was firstly proposed by Nakamoto Satoshi in 2008, we can clearly find that more and more people pay much attention to this emerging technology.
%Blockchain is defined as the next generation of technology and it can be widely used in various fields such as supply chain, healthcare and so on. Nevertheless, there are still some shortcomings to overcome in blockchain, such as long transaction latency and low transaction throughput. Take Hyperledger Fabric \cite{11DBLP:conf/eurosys/AndroulakiBBCCC18} as an example.
Fabric \cite{11DBLP:conf/eurosys/AndroulakiBBCCC18} is a permissioned Blockchain platform, where a CA (Certificate Authority) is introduced to manage the members, and every node needs to make a request for membership to CA before it joins the network.
Digital signature algorithm ECDSA (Ellipse Curve Digital Signature Algorithm) is widely adopted in Fabric to guarantee the validity of transactions. To avoid inconsistency in transaction states, the client needs to collect enough number of signatures from different endorsers satisfying the endorsement policy in Fabric. If the endorsement policy requires a large number of endorsers, the number of signatures would be large, and the overhead of signature verification would be high. In this case, the current mechanism of Fabric will lead to significant drops of the transaction efficiency.

Therefore, we try to introduce the proposed AGMS scheme into Fabric to optimize the current transaction process. In this paper, we implement the proposed AGMS on Fabric v1.0. In order to avoid confusion, we name original Fabric v1.0 as the default Fabric, and Fabric with AGMS as the revised Fabric. Compared to the default Fabric transaction process, we adopt our multi-signature scheme AGMS to replace ECDSA and add one synchronization step to run smoothly in the revised Fabric transaction process.
We assume the client as \(Cl\), the endorser as \(En_i\), and the orderer as \(Or\). We also define \(C_i\) as the set of children of one endorser \(En_i\),  \(P_i\) as the parent of the endorser \(En_i\), and \(N\) as the number of endorsers required by endorsement policy. As shown in Fig. \ref{figtransaction}, the revised Fabric transaction process can be described as follows.

\begin{figure}
\includegraphics[width=0.5\textwidth]{transaction-eps-converted-to.pdf}
\caption{The revised Fabric transaction process}
\label{figtransaction}
\end{figure}

Firstly, CA uses \(\textsf{Pg}(\kappa)\) to output \(par=(\mathbb{G},g_1,q)\). And then, each node uses \(\textsf{Kg}(par)\) to generate its own public/private key pair \((pk,sk)\). Before a node joins the Fabric network, CA additionally uses \(\textsf{KVf}(par,pk)\) to verify the validity of the node's identity and its public key. If the result is true, CA issues a certificate to the node so that it can successfully join the network. Otherwise, CA rejects the node, meaning that the node has no right to join the network of Fabric.

\noindent\textbf{Step 1: Synchronization.} All the endorsers \(En_i(i=1,\cdots,N)\) designated by endorsement policy can work as a sub-group in a spanning tree structure \(\tau\). They can synchronize the block information and implement phase 1 of \(\textsf{Sign}(par,(pk_i,sk_i),m,\tau)\). The client \(Cl\) works as the leader, implementing phase 2 of \(\textsf{Sign}(par,(pk_i,sk_i),m,\tau)\) to produce a common challenge \(c\), which acts as a part of the joint signature and is sent to each endorsers. The aggregated public key \(\tilde{X}\) is also computed in this section by \(\textsf{KAg}(\mathcal{PK})\).

\noindent\textbf{Step 2: Transaction Proposal.} When the client \(Cl\) needs to request a transaction \(m\), it firstly implements phase 3 of \(\textsf{Sign}(par,(pk_i,sk_i),m,\tau)\), sending the transaction proposal of \(m\) to the designated endorsers
\(En_i(i=1,\cdots,N)\) in a sub-group in a top-down way.

\noindent\textbf{Step 3: Endorsement.} When the endorser \(En_i\) receives a proposal from the client \(Cl\), it first uses \(\textsf{KVf}(par,pk)\) to check validity of the client \(Cl\)'s identity, then simulates the transaction implementation and signs the transaction proposal with its own private key and the previous common challenge \(c\). Finally, the endorser \(En_i\) implements phase 4 of \(\textsf{Sign}(par,(pk_i,sk_i),m,\tau)\), computing the partial response value \({s}_i\).

\noindent\textbf{Step 4: Proposal Response.} Then, all the designated endorsers \(En_i(i=1,\cdots,N)\) proceed to implement phase 4 of \(\textsf{Sign}(par,(pk_i,sk_i),m,\tau)\), sending back the proposal response bottom-up. The client \(Cl\) only needs to collect all the proposal responses from its children endorsers \(j\), which includes the simulated transaction results and the partial response values \(\tilde{s}_j\). When all the proposal responses are received, the client \(Cl\) checks the transaction results and computes \(S=\tilde{s}_{Cl}=s_{Cl}+\sum_{j\in C_{Cl}}\tilde{s}_j\). Finally, the client \(Cl\) successfully produces a joint signature \(\sigma=(c,S)\) representing the client \(Cl\) and all the designated endorsers \(En_i(i=1,\cdots,N)\). This joint signature can be easily verified by all nodes including the client \(Cl\) itself, so as to check whether it satisfies the endorsement policy.

\noindent\textbf{Step 5: Transaction Submission.} If the joint signature is valid, the client \(Cl\) sends the final transaction proposal and response to an orderer \(Or\).

\noindent\textbf{Step 6: Block Delivery.} The orderer \(Or\) orders the transactions from different clients into blocks and broadcasts them on the network;

\noindent\textbf{Step 7: Ledger Updated.} All the nodes on the network need to use \(\textsf{Vf}(par,\tilde{X},m,\sigma)\) to verify the block information and update synchronously.

%\begin{figure}.
%\includegraphics[width=\textwidth]{block.jpg}
%\caption{the block structure in Hyperledger Fabric} \label{fig5}
%\end{figure}

%Fig. \ref{fig5} clearly shows the structure of a block in Hyperledger Fabric v1.0 \cite{11DBLP:conf/eurosys/AndroulakiBBCCC18}.

Some relevant experiments are shown in Fig. \ref{figHY1}, Fig. \ref{figHY2}, Fig. \ref{figHY3} and Fig. \ref{figHY4} respectively. We mainly test the running time of signing algorithm in different transaction sections on a client node for the default Fabric and the revised Fabric. All the configurations are the same as those in Section VI. We assume that we can set different numbers of endorsers without limitation and there is no delay in communication. Fig. \ref{figHY2} shows that, compared to the default Fabric, the revised Fabric transaction process runs much faster when a transaction comes. This is because the revised transaction process runs Step 1 shown in Fig. \ref{figHY1} in advance, which does not exist in the default Fabric. This step leads to a much faster online signing.
From Fig. \ref{figHY3}, in terms of Step 5 to Step 7, as the verification algorithm of ECDSA is implemented one time for each endorser, the CPU running time of the default Fabric increases linearly with the number of endorsers. But in the revised Fabric, the verification algorithm is only implemented once regardless of the number of endorsers. Thus, the CPU running time is almost constant.
Therefore, we can take advantage of this extra time to implement Step 1, and the total time of the revised Fabric transaction process is still shorter than that of the default Fabric. The results are shown in Fig. \ref{figHY4}.
In general, by applying the proposed multi-signature scheme AGMS to replace ECDSA in the default Fabric, the revised Fabric transaction process has faster online signing and verification performance and smaller storage space, so that we can achieve the goal of improving the transaction efficiency and reducing the transaction storage in a block.

\begin{figure*}
\begin{minipage}[t]{0.45\linewidth}
\centering
\includegraphics[width=\textwidth]{Fig8.jpg}
\caption{The CPU running time of Step 1 on a client node in the revised Fabric transaction process ($y$-axis has logarithmic scale.)} \label{figHY1}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\linewidth}
\centering
\includegraphics[width=\textwidth]{Fig9.jpg}
\caption{The CPU running time from Step 2 to Step 4 on a client node between the default Fabric transaction process and the revised Fabric transaction process ($y$-axis has logarithmic scale.)} \label{figHY2}
\end{minipage}
\end{figure*}

\begin{figure*}
\begin{minipage}[t]{0.45\linewidth}
\centering
\includegraphics[width=\textwidth]{Fig10.jpg}
\caption{The CPU running time from Step 5 to Step 7 on a client node between the default Fabric transaction process and the revised Fabric transaction process ($y$-axis has logarithmic scale.)} \label{figHY3}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\linewidth}
\centering
\includegraphics[width=\textwidth]{Fig11.jpg}
\caption{The total CPU running time on a client node between the default Fabric transaction process and the revised Fabric transaction process ($y$-axis has logarithmic scale.)} \label{figHY4}
\end{minipage}
\end{figure*}

Please note that although the proposed multi-signature scheme, AGMS, is implemented on Fabric, a permission based Blockchain platform, AGMS is also useful for permissionless Blockchain platforms, as it's not based on the assumption of Trusted Authority (TA). Taking a public and permissionless Blockchain Bitcoin as an example, there exists Multisig address \cite{andresen2011m}, which is the hash of $n$ public keys $(pk_1,pk_2,\ldots,pk_n)$. To spend funds associated with this address, one creates a transaction containing signatures from these $n$ public keys $(pk_1,pk_2,\ldots,pk_n)$. Authors in \cite{DBLP:journals/dcc/MaxwellPSW19} use multi-signature to aggregate multiple signatures into a joint one, so as to shrink the size of transaction data associated with Bitcoin Multisig addresses. Compared to the permissioned application, without a CA verifying the nodes' identities and permitting the entrance to Blockchain, the probability of attacks would increase. Nevertheless, the attacks can still be identified by the key verification and signature verification algorithms, which is guaranteed by the security of the proposed multi-signature schemes.

\section{Conclusion}
%in this paper, we propose our scheme from two aspects: one is to improve security of cosi \cite{02dblp:conf/sp/sytatvwjggkf16}, because of some existing attacks such as rogue-key attack and \(k\)-sum problem attack \cite{03drijverssecurity}, the other is to modify gamma-signature scheme \cite{01dblp:journals/tifs/yaoz13} and apply it to other types of signature. multi-signature is one of applications, where we thought it appropriate to make use of gamma-signature \cite{01dblp:journals/tifs/yaoz13}.

%combined with a spanning tree structure and proof of possession \cite{05dblp:conf/eurocrypt/ristenparty07}, which both of them we thought are necessary to achieve the scalability and improve the security performance, our proposed multi-signature scheme shows more advantages over some other multi-signature schemes. meanwhile, we use forking lemma \cite{04dblp:conf/ccs/bellaren06} to give a detailed security proof of such a scheme under discrete logarithm assumption.

%otherwise, after analyzing the whole transaction process in a blockchain project---hyperledger fabric \cite{11dblp:conf/eurosys/androulakibbccc18}, we can find that there exists some improvement space in achieving the goal of increasing the transaction throughout and reducing the block storage. as we mentioned above, it is very useful to introduce multi-signature into fabric \cite{11dblp:conf/eurosys/androulakibbccc18}, especially gamma signature \cite{02dblp:conf/sp/sytatvwjggkf16} can be constructed on general elliptic curve group, so our proposed scheme is very compatible with hyperledger fabric \cite{11dblp:conf/eurosys/androulakibbccc18}.
%finally, looking into the future, we hope to extend our proposed scheme to multi-signature with different properties, such as identify-based multi-signature, aggregate signature and so on. we also thought it feels like an interesting question to apply our scheme to other decentralized systems or other available scenes.
This paper proposes two multi-signature schemes based on Gamma signature. Compared to CoSi, the most popular multi-signature scheme based on Schnorr signature, the proposed schemes achieves enhanced security, higher online efficiency and similar scalability. We also apply the proposed AGMS to improve the transaction process of Fabric, so that the efficiency and throughput of Fabric are enhanced.

Undoubtedly, there are some limitations for the proposed multi-signature schemes in real-life implementation. If there exists tamper or forge in the multi-signature, the joint signature cannot pass the verification algorithm. However, the nodes in the tree need to verify the partial responses top-down to find out the malicious signer, which would increase the running costs. If the multiple signers are chosen in rotations, the malicious singer continuously sending wrong responses would be identified efficiently, leading to negligible attack probability. In addition, the revised Fabric transaction process is only suitable for the case where the endorsement policy is set as ``AND'', but not for ``OR'', ``NOT''. These limitations will be investigated more in-depth in our future work.

% if have a single appendix:
%\appendix[Proof of the Zonklar Equations]
% or
%\appendix  % for no appendix heading
% do not use \section anymore after \appendix, only \section*
% is possibly needed

% use appendices with more than one appendix
% then use \section to start each appendix
% you must declare a \section before using any
% \subsection or using \label (\appendices by itself
% starts a section numbered zero.)
%
% use section* for acknowledgment

% Can use something like this to put references on a page
% by themselves when using endfloat and the captionsoff option.
\ifCLASSOPTIONcaptionsoff
  \newpage
\fi



% trigger a \newpage just before the given reference
% number - used to balance the columns on the last page
% adjust value as needed - may need to be readjusted if
% the document is modified later
%\IEEEtriggeratref{8}
% The "triggered" command can be changed if desired:
%\IEEEtriggercmd{\enlargethispage{-5in}}

% references section

% can use a bibliography generated by BibTeX as a .bbl file
% BibTeX documentation can be easily obtained at:
% http://mirror.ctan.org/biblio/bibtex/contrib/doc/
% The IEEEtran BibTeX style support page is at:
% http://www.michaelshell.org/tex/ieeetran/bibtex/
\bibliographystyle{IEEEtran}
\bibliography{refer}
% argument is your BibTeX string definitions and bibliography database(s)
%\bibliography{IEEEabrv,../bib/paper}
%
% <OR> manually copy in the resultant .bbl file
% set second argument of \begin to the number of references
% (used to reserve space for the reference number labels box)


% biography section
%
% If you have an EPS/PDF photo (graphicx package needed) extra braces are
% needed around the contents of the optional argument to biography to prevent
% the LaTeX parser from getting confused when it sees the complicated
% \includegraphics command within an optional argument. (You could create
% your own custom macro containing the \includegraphics command to make things
% simpler here.)
%\begin{IEEEbiography}[{\includegraphics[width=1in,height=1.25in,clip,keepaspectratio]{mshell}}]{Michael Shell}
% or if you just want to reserve a space for a photo:
\begin{IEEEbiography}[{\includegraphics[width=1in,height=1.25in,clip,keepaspectratio]{Yue.jpg}}]{Yue Xiao}
is a postgraduate student of College of Electronics and Information Engineering, Shenzhen University, China. He got the B.S. degree in telecommunication engineering from Guangdong Ocean University, China, in 2017, and the M.S. degree in information and telecommunication engineering from Shenzhen University, China, in 2020. His current research interests include cryptography technology and security in the Blockchain.
\end{IEEEbiography}

\begin{IEEEbiography}[{\includegraphics[width=1in,height=1.25in,clip,keepaspectratio]{Peng.jpg}}]{Peng Zhang}
is an associate professor of College of Electronics and Information Engineering, Shenzhen University, China. She got the Ph.D. degree in signal and information processing from Shenzhen University, China in 2011. Her current research interests include cryptography technology and security in the Blockchain, Cloud Computing, IoT. She has published more than 30 academic journal and conference papers.
\end{IEEEbiography}

\begin{IEEEbiography}[{\includegraphics[width=1in,height=1.25in,clip,keepaspectratio]{Yuhong.jpg}}]{Yuhong Liu}
is an Associate Professor at Department of Computer Engineering Santa Clara University. She received her B.S. and M.S. degree from Beijing University of Posts and Telecommunications in 2004 and 2007 respectively, and the Ph.D. degree from University of Rhode Island in 2012. Her research interests include trustworthy computing and cyber security of emerging applications, such as online social media, Internet-of-things, and Blockchain.
\end{IEEEbiography}
% that's all folks
\end{document}
